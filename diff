diff --git a/app/diffget/diffget.lisp b/app/diffget/diffget.lisp
index d1add75..0283f3e 100644
--- a/app/diffget/diffget.lisp
+++ b/app/diffget/diffget.lisp
@@ -1,39 +1,39 @@
-(require :stdlib *module-stdlib*)
-
-; 元になるファイルと、それと比較するファイルを用意する。
-; 元になるファイル群                              ：DIR1
-; 比較するファイル群                              ：DIR2
-; 元のファイルにあり、
-; 比較するファイルにない行を吐き出したファイル群  ：DIR1-DIR2
-
-(defexe diffget  (-e --help)
-  "e:help"
-  (echo "diffget start")
-  (let* ((usage (usage :title "diffget [DIR1] [DIR2] [OPTION]..."
-                       :desc  "Get different line with the same name file of [DIR1] and [DIR2]."
-                       :opts  '("-e" "extension of terget file (default value `dat'")))
-         (origin-dir (first args))
-         (test-dir (second args))
-         (result-dir (mkstr origin-dir "-" test-dir)))
-    (when (or --help
-              errors
-              (null origin-dir)
-              (null test-dir))
-      (funcall usage))
-    (with-encoding (:cp932 :windows)
-      (mapfile (lambda (pathname)
-                 (let* ((fname (file-namestring pathname))
-                        (ori-path (mkstr origin-dir "/" fname))
-                        (test-path (mkstr test-dir "/" fname))
-                        (result-path (mkstr result-dir "/" fname)))
-                   (echo "  start" fname)
-                   (when (file-exists? test-path)
-                     (write-to! (nset-difference
-                                  (read-from ori-path)
-                                  (read-from test-path)
-                                  :test #'string=)
-                                result-path)
-                     (echo "  finish" fname))))
-               :directory origin-dir
-               :extension (or -e 'dat))))
-  (echo "finished"))
+(require :stdlib *module-stdlib*)
+
+; 元になるファイルと、それと比較するファイルを用意する。
+; 元になるファイル群                              ：DIR1
+; 比較するファイル群                              ：DIR2
+; 元のファイルにあり、
+; 比較するファイルにない行を吐き出したファイル群  ：DIR1-DIR2
+
+(defexe diffget  (-e --help)
+  "e:help"
+  (echo "diffget start")
+  (let* ((usage (usage :title "diffget [DIR1] [DIR2] [OPTION]..."
+                       :desc  "Get different line with the same name file of [DIR1] and [DIR2]."
+                       :opts  '("-e" "extension of terget file (default value `dat'")))
+         (origin-dir (first args))
+         (test-dir (second args))
+         (result-dir (mkstr origin-dir "-" test-dir)))
+    (when (or --help
+              errors
+              (null origin-dir)
+              (null test-dir))
+      (funcall usage))
+    (with-encoding (:cp932 :windows)
+      (mapfile (lambda (pathname)
+                 (let* ((fname (file-namestring pathname))
+                        (ori-path (mkstr origin-dir "/" fname))
+                        (test-path (mkstr test-dir "/" fname))
+                        (result-path (mkstr result-dir "/" fname)))
+                   (echo "  start" fname)
+                   (when (file-exists? test-path)
+                     (write-to! (nset-difference
+                                  (read-from ori-path)
+                                  (read-from test-path)
+                                  :test #'string=)
+                                result-path)
+                     (echo "  finish" fname))))
+               :directory origin-dir
+               :extension (or -e 'dat))))
+  (echo "finished"))
diff --git a/app/diverge/diverge.lisp b/app/diverge/diverge.lisp
index d70dec1..f966c73 100644
--- a/app/diverge/diverge.lisp
+++ b/app/diverge/diverge.lisp
@@ -1,47 +1,47 @@
-(require :stdlib *module-stdlib*)
-
-(let ((index 0))
-  (defun reset-index ()
-    (setq index 0))
-  (defun output (pathname lis)
-    (when lis
-      (let ((fname (mkstr (file-namestring pathname) "_" (mkindex (incf index)) ".dat")))
-        (echo "  output: " fname)
-        (write-to lis fname)))))
-
-(defun mkindex (num)
-  (cond ((< num 10)
-         (mkstr 0 0 num))
-        ((< num 100)
-         (mkstr 0 num))
-        (t num)))
-
-(defexe diverge ((-n --split-num) (-e --extension) -r --help)
-  "n:split-num:e:extension:r;help"
-  (let ((usage (usage :title "diverge [OPTION}..."
-                      :desc  "Split file utility."
-                      :opts '("-n, --split-num=" "number of split line"
-                              "-e, --extension=" "target file extension. default 'csv'"
-                              "-r" "split file recursive")))
-        (split-line-num (aif (or -n --split-num) (parse-integer it) 10000))
-        (extension (aif (or -e --extension) (intern it) 'csv)))
-    (when (or --help errors)
-      (funcall usage))
-    (mapfile (lambda (pathname)
-               (echo "start: " pathname)
-               (reset-index)
-               (with-encoding (guess-encoding pathname)
-                 (with-open-file (in pathname :direction :input :if-does-not-exist nil)
-                   (let ((output-lines nil))
-                     (do ((line (read-line in nil nil) (read-line in nil nil))
-                          (line-num 0 (1+ line-num)))
-                       ((null line))
-                       (push line output-lines)
-                       (when (= (mod (1+ line-num) split-line-num) 0)
-                         (output pathname (nreverse output-lines))
-                         (setq output-lines nil)))
-                     (output pathname (nreverse output-lines))
-                     (echo "end: " pathname)))))
-             :extension extension
-             :recursive -r))
-  (echo "finished."))
+(require :stdlib *module-stdlib*)
+
+(let ((index 0))
+  (defun reset-index ()
+    (setq index 0))
+  (defun output (pathname lis)
+    (when lis
+      (let ((fname (mkstr (file-namestring pathname) "_" (mkindex (incf index)) ".dat")))
+        (echo "  output: " fname)
+        (write-to lis fname)))))
+
+(defun mkindex (num)
+  (cond ((< num 10)
+         (mkstr 0 0 num))
+        ((< num 100)
+         (mkstr 0 num))
+        (t num)))
+
+(defexe diverge ((-n --split-num) (-e --extension) -r --help)
+  "n:split-num:e:extension:r;help"
+  (let ((usage (usage :title "diverge [OPTION}..."
+                      :desc  "Split file utility."
+                      :opts '("-n, --split-num=" "number of split line"
+                              "-e, --extension=" "target file extension. default 'csv'"
+                              "-r" "split file recursive")))
+        (split-line-num (aif (or -n --split-num) (parse-integer it) 10000))
+        (extension (aif (or -e --extension) (intern it) 'csv)))
+    (when (or --help errors)
+      (funcall usage))
+    (mapfile (lambda (pathname)
+               (echo "start: " pathname)
+               (reset-index)
+               (with-encoding (guess-encoding pathname)
+                 (with-open-file (in pathname :direction :input :if-does-not-exist nil)
+                   (let ((output-lines nil))
+                     (do ((line (read-line in nil nil) (read-line in nil nil))
+                          (line-num 0 (1+ line-num)))
+                       ((null line))
+                       (push line output-lines)
+                       (when (= (mod (1+ line-num) split-line-num) 0)
+                         (output pathname (nreverse output-lines))
+                         (setq output-lines nil)))
+                     (output pathname (nreverse output-lines))
+                     (echo "end: " pathname)))))
+             :extension extension
+             :recursive -r))
+  (echo "finished."))
diff --git a/app/fmerge/fmerge.lisp b/app/fmerge/fmerge.lisp
index c3bd056..41cf7df 100644
--- a/app/fmerge/fmerge.lisp
+++ b/app/fmerge/fmerge.lisp
@@ -1,24 +1,22 @@
-
-(load "../../lib/stdlib")
-
-;; exeのあるフォルダ内のdatファイルが対象
-(defexe fmerge (--help)
-  "help"
-  (let ((usage (usage :title "fmerge [OPTION]"
-                      :desc  "Merge file utility."
-                      :opts  '())))
-    (when (or --help errors)
-      (echo (pop errors))
-      (funcall usage))
-    (echo "start")
-    (mapfile (lambda (pathname)
-               (let* ((file-from (file-namestring pathname))
-                      (file-to (before #\_ file-from)))
-                 (echo "  merge: " file-from " => " file-to)
-                 (write-to (read-from pathname) file-to
-                           :enc :cp932
-                           :ff :windows)))
-             :extension 'dat)
-    (echo "finished.")))
-
-
+(load "../../lib/stdlib")
+
+;; exeのあるフォルダ内のdatファイルが対象
+(defexe fmerge (--help)
+  "help"
+  (let ((usage (usage :title "fmerge [OPTION]"
+                      :desc  "Merge file utility."
+                      :opts  '())))
+    (when (or --help errors)
+      (echo (pop errors))
+      (funcall usage))
+    (echo "start")
+    (mapfile (lambda (pathname)
+               (let* ((file-from (file-namestring pathname))
+                      (file-to (before #\_ file-from)))
+                 (echo "  merge: " file-from " => " file-to)
+                 (write-to (read-from pathname) file-to
+                           :enc :cp932
+                           :ff :windows)))
+             :extension 'dat)
+    (echo "finished.")))
+
diff --git a/app/oracle/get-session/get-session.lisp b/app/oracle/get-session/get-session.lisp
index 89e0700..9c44b84 100644
--- a/app/oracle/get-session/get-session.lisp
+++ b/app/oracle/get-session/get-session.lisp
@@ -1,4 +1,3 @@
-
 (load "../../../lib/stdlib")
 (load "../ora-lib")
 
@@ -52,4 +51,3 @@ END)
                      (mkstr-if -i
                        "   S.STATUS = 'INACTIVE' AND ")
                      "   1 = 1; ")))))
-
diff --git a/app/oracle/kill-session/kill-session.lisp b/app/oracle/kill-session/kill-session.lisp
index a3b78ee..28f2c3f 100644
--- a/app/oracle/kill-session/kill-session.lisp
+++ b/app/oracle/kill-session/kill-session.lisp
@@ -1,4 +1,3 @@
-
 (load "../../../lib/stdlib")
 (load "../ora-lib")
 
@@ -31,4 +30,3 @@
                                           it))
                    (delete-file tmp-file)))
     (echo "finished")))
-
diff --git a/app/oracle/mktab/mktab.lisp b/app/oracle/mktab/mktab.lisp
index ac83f54..c0902cf 100644
--- a/app/oracle/mktab/mktab.lisp
+++ b/app/oracle/mktab/mktab.lisp
@@ -1,45 +1,43 @@
-
-(load "../../../lib/stdlib")
-(load "../ora-lib")
-
-(defexe mktab (-n -o (-t --table) --help)
-  "n;o;t:table:help"
-  (with-encoding (:cp932 :windows)
-    (let ((args (list->string args #\Space))
-          (usage (usage :title "mktab [OPTION} [SCHEMA]/[PASSWORD]@[SID]"
-                        :desc  "Create tab files."
-                        :opts  '("-o" "only output tabs file"
-                                 "-t, --table=[]" "output only table"
-                                 "-n" "append num of records to a tabs file"))))
-      (with-dbinfo args
-                   (let ((tabs (mkstr schema ".tabs")))
-                     (execute-query
-                       (mkstr "SELECT TABLE_NAME "
-                              "FROM TABS "
-                              (awhen (or -t --table)
-                                (mkstr "WHERE TABLE_NAME = '"
-                                       (string-upcase it))) "';")
-                       :spool tabs)
-                     (unless -o
-                       (mkdir schema)
-                       (mapcan (lambda (table)
-                                 (execute-query
-                                   (mkstr "SELECT COLUMN_NAME "
-                                          "FROM ALL_TAB_COLUMNS "
-                                          "WHERE OWNER = '" schema "' AND "
-                                          "TABLE_NAME = '" table "' "
-                                          "ORDER BY COLUMN_ID;")
-                                   :spool (mkstr schema "/" table ".tab")))
-                               (read-from tabs)))
-                     (when -n
-                       (execute-query 
-                         (mapcar (lambda (table)
-                                   (mkstr "SELECT '" table "'||','|| COUNT(*) "
-                                          "FROM " table ";"))
-                                 (prog1
-                                   (read-from tabs)
-                                   (delete-file tabs)))
-                         :spool tabs)))
-                   (echo "finished.")))))
-
-
+(load "../../../lib/stdlib")
+(load "../ora-lib")
+
+(defexe mktab (-n -o (-t --table) --help)
+  "n;o;t:table:help"
+  (with-encoding (:cp932 :windows)
+    (let ((args (list->string args #\Space))
+          (usage (usage :title "mktab [OPTION} [SCHEMA]/[PASSWORD]@[SID]"
+                        :desc  "Create tab files."
+                        :opts  '("-o" "only output tabs file"
+                                 "-t, --table=[]" "output only table"
+                                 "-n" "append num of records to a tabs file"))))
+      (with-dbinfo args
+                   (let ((tabs (mkstr schema ".tabs")))
+                     (execute-query
+                       (mkstr "SELECT TABLE_NAME "
+                              "FROM TABS "
+                              (awhen (or -t --table)
+                                (mkstr "WHERE TABLE_NAME = '"
+                                       (string-upcase it))) "';")
+                       :spool tabs)
+                     (unless -o
+                       (mkdir schema)
+                       (mapcan (lambda (table)
+                                 (execute-query
+                                   (mkstr "SELECT COLUMN_NAME "
+                                          "FROM ALL_TAB_COLUMNS "
+                                          "WHERE OWNER = '" schema "' AND "
+                                          "TABLE_NAME = '" table "' "
+                                          "ORDER BY COLUMN_ID;")
+                                   :spool (mkstr schema "/" table ".tab")))
+                               (read-from tabs)))
+                     (when -n
+                       (execute-query 
+                         (mapcar (lambda (table)
+                                   (mkstr "SELECT '" table "'||','|| COUNT(*) "
+                                          "FROM " table ";"))
+                                 (prog1
+                                   (read-from tabs)
+                                   (delete-file tabs)))
+                         :spool tabs)))
+                   (echo "finished.")))))
+
diff --git a/app/oracle/ora-lib.lisp b/app/oracle/ora-lib.lisp
index e1db9c1..f6ed479 100644
--- a/app/oracle/ora-lib.lisp
+++ b/app/oracle/ora-lib.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 ;; required function 'usage'
@@ -45,4 +44,3 @@
 
 (defun call-sqlplus (schema pass sid argfile)
   (call "sqlplus" (mkstr "-L -S " schema "/" pass "@" sid " @" argfile) *standard-output*))
-
diff --git a/app/oracle/spool/spool.lisp b/app/oracle/spool/spool.lisp
index a4b6fda..2c0739d 100644
--- a/app/oracle/spool/spool.lisp
+++ b/app/oracle/spool/spool.lisp
@@ -1,4 +1,3 @@
-
 (load "../../../lib/stdlib")
 (load "../ora-lib")
 
@@ -20,4 +19,3 @@
     (echo "finished.")))
 
 
-
diff --git a/app/oracle/tab-to-ctl/tab-to-ctl.lisp b/app/oracle/tab-to-ctl/tab-to-ctl.lisp
index cf3693a..9c77278 100644
--- a/app/oracle/tab-to-ctl/tab-to-ctl.lisp
+++ b/app/oracle/tab-to-ctl/tab-to-ctl.lisp
@@ -1,28 +1,26 @@
-
-(load "../../../lib/stdlib")
-
-(defun mkcols (cols)
-  (append (mapcar (lambda (x)
-                    (mkstr x ","))
-                  (butlast cols))
-          (last1 cols)))
-
-(defexe tab-to-ctl ()
-  (with-encoding (:cp932 :windows)
-    (mapfile (lambda (pathname)
-               (let ((table-name (pathname-name pathname)))
-                 (write-to!  (flatten (list
-                                        "LOAD DATA"
-                                        (mkstr "INFILE '" table-name ".csv'")
-                                        (mkstr "INTO TABLE " table-name)
-                                        "APPEND"
-                                        "FIELDS TERMINATED BY ','"
-                                        "TRAILING NULLCOLS"
-                                        "("
-                                        (mkcols (read-from pathname))
-                                        ")"))
-                             (mkstr table-name ".ctl"))))
-             :extension 'tab))
-  (echo "finished."))
-
-
+(load "../../../lib/stdlib")
+
+(defun mkcols (cols)
+  (append (mapcar (lambda (x)
+                    (mkstr x ","))
+                  (butlast cols))
+          (last1 cols)))
+
+(defexe tab-to-ctl ()
+  (with-encoding (:cp932 :windows)
+    (mapfile (lambda (pathname)
+               (let ((table-name (pathname-name pathname)))
+                 (write-to!  (flatten (list
+                                        "LOAD DATA"
+                                        (mkstr "INFILE '" table-name ".csv'")
+                                        (mkstr "INTO TABLE " table-name)
+                                        "APPEND"
+                                        "FIELDS TERMINATED BY ','"
+                                        "TRAILING NULLCOLS"
+                                        "("
+                                        (mkcols (read-from pathname))
+                                        ")"))
+                             (mkstr table-name ".ctl"))))
+             :extension 'tab))
+  (echo "finished."))
+
diff --git a/app/oracle/tab-to-spool/tab-to-spool.lisp b/app/oracle/tab-to-spool/tab-to-spool.lisp
index a3979d9..bea2e41 100644
--- a/app/oracle/tab-to-spool/tab-to-spool.lisp
+++ b/app/oracle/tab-to-spool/tab-to-spool.lisp
@@ -1,56 +1,54 @@
-
-(load "../../../lib/stdlib")
-(load "../ora-lib")
-
-(defvar *batch-file* "all.bat")
-
-(defun mkcols (cols escapep)
-  (let ((cols (if escapep
-                (mapcar (lambda (x)
-                          ; (mkstr "REPLACE(REPLACE(" x ", ',', '###'), CHR(13)||CHR(10), '\\n')"))
-                          (mkstr "REPLACE(" x ",CHR(10), '\\n')"))
-                        cols)
-                cols)))
-    (append (mapcar (lambda (x)
-                      (mkstr x " ||',' ||"))
-                    (butlast cols))
-            (last1 cols))))
-
-(defexe tab-to-spool (-e --help)
-  "e;help"
-  (with-encoding (:cp932 :windows)
-    (let ((args (list->string args #\Space))
-          (usage (usage :title "tab-to-spool [OPTION] [SCHEMA]/[PASSWORD]@[SID]"
-                        :desc  "Convert tab file to sql. (for sqlplus)"
-                        :opts  '("-e" "escape comma and CRLF."))))
-      (with-dbinfo args
-                   (mkfile! *batch-file*)
-                   (mapfile
-                     (lambda (pathname)
-                       (info 'start pathname)
-                       (let ((fname (pathname-name pathname))
-                             (cols (read-from pathname)))
-                         (write-to (mkstr "call sqlplus " schema "/" pass "@" sid " @" fname ".sql")
-                                   *batch-file*
-                                   :enc :cp932
-                                   :ff :windows)
-                         (write-to!  (flatten (list "SET ECHO OFF"
-                                                    "SET HEAD OFF"
-                                                    "SET LINESIZE 32767"
-                                                    "SET PAGESIZE 0"
-                                                    "SET TRIMSPOOL ON"
-                                                    "SET FEEDBACK OFF"
-                                                    "SET COLSEP ','"
-                                                    (mkstr "SPOOL " fname ".csv")
-                                                    "SELECT"
-                                                    (mkcols cols -e)
-                                                    (mkstr "FROM " schema "." fname ";")
-                                                    "SPOOL OFF"
-                                                    "EXIT"))
-                                     (mkstr fname ".sql")
-                                     :enc :cp932
-                                     :ff :windows)
-                         (info 'end)))
-                     :extension 'tab)))))
-
-
+(load "../../../lib/stdlib")
+(load "../ora-lib")
+
+(defvar *batch-file* "all.bat")
+
+(defun mkcols (cols escapep)
+  (let ((cols (if escapep
+                (mapcar (lambda (x)
+                          ; (mkstr "REPLACE(REPLACE(" x ", ',', '###'), CHR(13)||CHR(10), '\\n')"))
+                          (mkstr "REPLACE(" x ",CHR(10), '\\n')"))
+                        cols)
+                cols)))
+    (append (mapcar (lambda (x)
+                      (mkstr x " ||',' ||"))
+                    (butlast cols))
+            (last1 cols))))
+
+(defexe tab-to-spool (-e --help)
+  "e;help"
+  (with-encoding (:cp932 :windows)
+    (let ((args (list->string args #\Space))
+          (usage (usage :title "tab-to-spool [OPTION] [SCHEMA]/[PASSWORD]@[SID]"
+                        :desc  "Convert tab file to sql. (for sqlplus)"
+                        :opts  '("-e" "escape comma and CRLF."))))
+      (with-dbinfo args
+                   (mkfile! *batch-file*)
+                   (mapfile
+                     (lambda (pathname)
+                       (info 'start pathname)
+                       (let ((fname (pathname-name pathname))
+                             (cols (read-from pathname)))
+                         (write-to (mkstr "call sqlplus " schema "/" pass "@" sid " @" fname ".sql")
+                                   *batch-file*
+                                   :enc :cp932
+                                   :ff :windows)
+                         (write-to!  (flatten (list "SET ECHO OFF"
+                                                    "SET HEAD OFF"
+                                                    "SET LINESIZE 32767"
+                                                    "SET PAGESIZE 0"
+                                                    "SET TRIMSPOOL ON"
+                                                    "SET FEEDBACK OFF"
+                                                    "SET COLSEP ','"
+                                                    (mkstr "SPOOL " fname ".csv")
+                                                    "SELECT"
+                                                    (mkcols cols -e)
+                                                    (mkstr "FROM " schema "." fname ";")
+                                                    "SPOOL OFF"
+                                                    "EXIT"))
+                                     (mkstr fname ".sql")
+                                     :enc :cp932
+                                     :ff :windows)
+                         (info 'end)))
+                     :extension 'tab)))))
+
diff --git a/app/poemmer/poemmer.lisp b/app/poemmer/poemmer.lisp
index 5d871dc..330562b 100644
--- a/app/poemmer/poemmer.lisp
+++ b/app/poemmer/poemmer.lisp
@@ -1,4 +1,3 @@
-
 (load "../../lib/stdlib")
 
 (defparameter *words* (mkhash :size 10000))
@@ -78,4 +77,3 @@
         (read-text i)))
     (generate-text (aif (or -n --words) (parse-integer it) 100))))
 
-
diff --git a/app/rm-line/rm-line.lisp b/app/rm-line/rm-line.lisp
index 73bee7c..e630424 100644
--- a/app/rm-line/rm-line.lisp
+++ b/app/rm-line/rm-line.lisp
@@ -1,4 +1,3 @@
-
 (load "../../lib/stdlib")
 
 
@@ -21,4 +20,3 @@
       (mapcar #'echo (rec (read-from file) files)))))
 
 
-
diff --git a/app/sort/sort.lisp b/app/sort/sort.lisp
index dd76368..0d05391 100644
--- a/app/sort/sort.lisp
+++ b/app/sort/sort.lisp
@@ -22,4 +22,3 @@
              :extension extension
              :recursive -r))
   (echo "finished."))
-
diff --git a/app/typing/typing.lisp b/app/typing/typing.lisp
index 97831c3..4275cb2 100644
--- a/app/typing/typing.lisp
+++ b/app/typing/typing.lisp
@@ -1,4 +1,3 @@
-
 (load "../../lib/stdlib")
 
 (defvar *default-dic-path* "lisp.word")
@@ -43,4 +42,3 @@
         (incf *total-key-stroke* (length word)) 
         (while (not (string= word (read-line))))))
     (summary start-time)))
-
diff --git a/app/xpdf/xpdf.lisp b/app/xpdf/xpdf.lisp
index a880431..a159398 100644
--- a/app/xpdf/xpdf.lisp
+++ b/app/xpdf/xpdf.lisp
@@ -1,4 +1,3 @@
-
 (load "../../lib/stdlib")
 
 (defun pathname->pdf-file (pathname)
@@ -16,4 +15,3 @@
            :recursive t
            :extension 'pdf)
   (print "finish"))
-
diff --git a/bin/aprint/aprint.lisp b/bin/aprint/aprint.lisp
index 548b66a..1841f75 100644
--- a/bin/aprint/aprint.lisp
+++ b/bin/aprint/aprint.lisp
@@ -1,922 +1,920 @@
-
-(require :stdlib *module-stdlib*)
-(require :regex *module-regex*)
-
-(defparameter *surround-character* nil)
-(defparameter *bg-character* #\Space)
-
-(defun make-print-table ()
-  (let ((table (make-hash-table :size 80)))
-    ;; number {{{
-    ;; 0 {{{
-
-    (setf (gethash #\0 table)
-          (list "        "
-                "   _|   "
-                " _|  _| "
-                " _|  _| "
-                " _|  _| "
-                "   _|   "
-                "        "
-                "        "))
-
-    ;; }}}
-    ;; 1 {{{
-
-    (setf (gethash #\1 table)
-          (list "        "
-                "   _|   "
-                " _|_|   "
-                "   _|   "
-                "   _|   "
-                "   _|   "
-                "        "
-                "        "))
-
-    ;; }}}
-    ;; 2 {{{
-
-    (setf (gethash #\2 table)
-          (list "          "
-                "   _|_|   "
-                " _|    _| "
-                "     _|   "
-                "   _|     "
-                " _|_|_|_| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; 3 {{{
-
-    (setf (gethash #\3 table)
-          (list "          "
-                " _|_|_|   "
-                "       _| "
-                "   _|_|   "
-                "       _| "
-                " _|_|_|   "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; 4 {{{
-
-    (setf (gethash #\4 table)
-          (list "          "
-                " _|  _|   "
-                " _|  _|   "
-                " _|_|_|_| "
-                "     _|   "
-                "     _|   "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; 5 {{{
-
-    (setf (gethash #\5 table)
-          (list "          "
-                " _|_|_|_| "
-                " _|       "
-                " _|_|_|   "
-                "       _| "
-                " _|_|_|   "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; 6 {{{
-
-    (setf (gethash #\6 table)
-          (list "          "
-                "   _|_|_| "
-                " _|       "
-                " _|_|_|   "
-                " _|    _| "
-                "   _|_|   "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; 7 {{{
-
-    (setf (gethash #\7 table)
-          (list "          "
-                " _|_|_|_| "
-                "      _|  "
-                "    _|    "
-                "   _|     "
-                "  _|      "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; 8 {{{
-
-    (setf (gethash #\8 table)
-          (list "          "
-                "   _|_|   "
-                " _|    _| "
-                "   _|_|   "
-                " _|    _| "
-                "   _|_|   "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; 9 {{{
-
-    (setf (gethash #\9 table)
-          (list "          "
-                "   _|_|   "
-                " _|    _| "
-                "   _|_|_| "
-                "       _| "
-                " _|_|_|   "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; }}}
-    ;; [a-z] {{{
-    ;; a {{{
-
-    (setf (gethash #\a table)
-          (list "          "
-                "          "
-                "   _|_|_| "
-                " _|    _| "
-                " _|    _| "
-                "   _|_|_| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; b {{{
-
-    (setf (gethash #\b table)
-          (list "          "
-                " _|       "
-                " _|_|_|   "
-                " _|    _| "
-                " _|    _| "
-                " _|_|_|   "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; c {{{
-
-    (setf (gethash #\c table)
-          (list "          "
-                "          "
-                "   _|_|_| "
-                " _|       "
-                " _|       "
-                "   _|_|_| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; d {{{
-
-    (setf (gethash #\d table)
-          (list "       _| "
-                "       _| "
-                "   _|_|_| "
-                " _|    _| "
-                " _|    _| "
-                "   _|_|_| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; e {{{
-
-    (setf (gethash #\e table)
-          (list "          "
-                "          "
-                "   _|_|   "
-                " _|_|_|_| "
-                " _|       "
-                "   _|_|_| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; f {{{
-
-    (setf (gethash #\f table)
-          (list "          "
-                "     _|_| "
-                "   _|     "
-                " _|_|_|_| "
-                "   _|     "
-                "   _|     "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; g {{{
-
-    (setf (gethash #\g table)
-          (list "          "
-                "          "
-                "   _|_|_| "
-                " _|    _| "
-                " _|    _| "
-                "   _|_|_| "
-                "       _| "
-                "   _|_|   "))
-
-    ;; }}}
-    ;; h {{{
-
-    (setf (gethash #\h table)
-          (list "          "
-                " _|       "
-                " _|_|_|   "
-                " _|    _| "
-                " _|    _| "
-                " _|    _| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; i {{{
-
-    (setf (gethash #\i table)
-          (list "     "
-                "  _| "
-                "     "
-                "  _| "
-                "  _| "
-                "  _| "
-                "     "
-                "     "))
-
-    ;; }}}
-    ;; i {{{
-
-    (setf (gethash #\j table)
-          (list "      "
-                "   _| "
-                "      "
-                "   _| "
-                "   _| "
-                "   _| "
-                "  _|  "
-                " _|   "))
-
-    ;; }}}
-    ;; k {{{
-
-    (setf (gethash #\k table)
-          (list "          "
-                " _|       "
-                " _|  _|   "
-                " _|_|     "
-                " _|  _|   "
-                " _|    _| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; l {{{
-
-    (setf (gethash #\l table)
-          (list "     "
-                "  _| "
-                "  _| "
-                "  _| "
-                "  _| "
-                "  _| "
-                "     "
-                "     "))
-
-    ;; }}}
-    ;; m {{{
-
-    (setf (gethash #\m table)
-          (list "              "
-                "              "
-                " _|_|_| _|_|  "
-                " _|   _|   _| "
-                " _|   _|   _| "
-                " _|   _|   _| "
-                "              "
-                "              "))
-
-    ;; }}}
-    ;; n {{{
-
-    (setf (gethash #\n table)
-          (list "          "
-                "          "
-                "  _|_|_|  "
-                " _|    _| "
-                " _|    _| "
-                " _|    _| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; o {{{
-
-    (setf (gethash #\o table)
-          (list "          "
-                "          "
-                "   _|_|   "
-                " _|    _| "
-                " _|    _| "
-                "   _|_|   "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; p {{{
-
-    (setf (gethash #\p table)
-          (list "          "
-                "          "
-                " _|_|_|   "
-                " _|    _| "
-                " _|    _| "
-                " _|_|_|   "
-                " _|       "
-                " _|       "))
-
-    ;; }}}
-    ;; p {{{
-
-    (setf (gethash #\q table)
-          (list "          "
-                "          "
-                "   _|_|_| "
-                " _|    _| "
-                " _|    _| "
-                "   _|_|_| "
-                "       _| "
-                "       _| "))
-
-    ;; }}}
-    ;; r {{{
-
-    (setf (gethash #\r table)
-          (list "          "
-                "          "
-                " _|  _|_| "
-                " _|_|     "
-                " _|       "
-                " _|       "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; s {{{
-
-    (setf (gethash #\s table)
-          (list "          "
-                "          "
-                "   _|_|_| "
-                " _|_|     "
-                "     _|_| "
-                " _|_|_|   "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; t {{{
-
-    (setf (gethash #\t table)
-          (list "          "
-                "   _|     "
-                " _|_|_|_| "
-                "   _|     "
-                "   _|     "
-                "     _|_| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; u {{{
-
-    (setf (gethash #\u table)
-          (list "          "
-                "          "
-                " _|    _| "
-                " _|    _| "
-                " _|    _| "
-                "   _|_|_| "
-                "          "
-                "          "))
-
-    ;; }}}
-    ;; v {{{
-
-    (setf (gethash #\v table)
-          (list "               "
-                "               "
-                "  _|        _| "
-                "   _|      _|  "
-                "     _|  _|    "
-                "       _|      "
-                "               "
-                "               "))
-
-    ;; }}}
-    ;; w {{{
-
-    (setf (gethash #\w table)
-          (list "                    "
-                "                    "
-                " _|      _|      _| "
-                "  _|     _|     _|  "
-                "   _|  _|  _|  _|   "
-                "     _|      _|     "
-                "                    "
-                "                    "))
-
-    ;; }}}
-    ;; x {{{
-
-    (setf (gethash #\x table)
-          (list "           "
-                "           "
-                "  _|    _| "
-                "    _|_|   "
-                "    _|_|   "
-                "  _|    _| "
-                "           "
-                "           "))
-
-    ;; }}}
-    ;; y {{{
-
-    (setf (gethash #\y table)
-          (list "          "
-                "          "
-                " _|    _| "
-                " _|    _| "
-                " _|    _| "
-                "   _|_|_| "
-                "       _| "
-                "   _|_|   "))
-
-    ;; }}}
-    ;; z {{{
-
-    (setf (gethash #\z table)
-          (list "           "
-                "           "
-                "  _|_|_|_| "
-                "      _|   "
-                "    _|     "
-                "  _|_|_|_| "
-                "           "
-                "           "))
-
-    ;; }}}
-    ;; }}}
-    ;; [A-Z] {{{
-    ;; A {{{
-
-    (setf  (gethash #\A table)
-           (list "          "
-                 "   _|_|   "
-                 " _|    _| "
-                 " _|_|_|_| "
-                 " _|    _| "
-                 " _|    _| "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; B {{{
-
-    (setf  (gethash #\B table)
-           (list "          "
-                 " _|_|_|   "
-                 " _|    _| "
-                 " _|_|_|   "
-                 " _|    _| "
-                 " _|_|_|   "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; C {{{
-
-    (setf  (gethash #\C table)
-           (list "          "
-                 "   _|_|_| "
-                 " _|       "
-                 " _|       "
-                 " _|       "
-                 "   _|_|_| "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; D {{{
-
-    (setf  (gethash #\D table)
-           (list "          "
-                 " _|_|_|   "
-                 " _|    _| "
-                 " _|    _| "
-                 " _|    _| "
-                 " _|_|_|   "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; E {{{
-
-    (setf  (gethash #\E table)
-           (list "          "
-                 " _|_|_|_| "
-                 " _|       "
-                 " _|_|_|   "
-                 " _|       "
-                 " _|_|_|_| "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; F {{{
-
-    (setf  (gethash #\F table)
-           (list "          "
-                 " _|_|_|_| "
-                 " _|       "
-                 " _|_|_|   "
-                 " _|       "
-                 " _|       "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; G {{{
-
-    (setf  (gethash #\G table)
-           (list "          "
-                 "   _|_|_| "
-                 " _|       "
-                 " _|  _|_| "
-                 " _|    _| "
-                 "   _|_|_| "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; H {{{
-
-    (setf  (gethash #\H table)
-           (list "          "
-                 " _|    _| "
-                 " _|    _| "
-                 " _|_|_|_| "
-                 " _|    _| "
-                 " _|    _| "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; I {{{
-
-    (setf  (gethash #\I table)
-           (list "        "
-                 " _|_|_| "
-                 "   _|   "
-                 "   _|   "
-                 "   _|   "
-                 " _|_|_| "
-                 "        "
-                 "        "))
-
-    ;; }}}
-    ;; J {{{
-
-    (setf  (gethash #\J table)
-           (list "          "
-                 "       _| "
-                 "       _| "
-                 "       _| "
-                 " _|    _| "
-                 "   _|_|   "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; K {{{
-
-    (setf  (gethash #\K table)
-           (list "          "
-                 " _|    _| "
-                 " _|  _|   "
-                 " _|_|     "
-                 " _|  _|   "
-                 " _|    _| "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; L {{{
-
-    (setf  (gethash #\L table)
-           (list "          "
-                 " _|       "
-                 " _|       "
-                 " _|       "
-                 " _|       "
-                 " _|_|_|_| "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; M {{{
-
-    (setf  (gethash #\M table)
-           (list "           "
-                 "_|      _| "
-                 "_|_|  _|_| "
-                 "_|  _|  _| "
-                 "_|      _| "
-                 "_|      _| "
-                 "           "
-                 "           "))
-
-    ;; }}}
-    ;; N {{{
-
-    (setf  (gethash #\N table)
-           (list "             "
-                 "  _|      _| "
-                 "  _|_|    _| "
-                 "  _|  _|  _| "
-                 "  _|    _|_| "
-                 "  _|      _| "
-                 "             "
-                 "             "))
-
-    ;; }}}
-    ;; O {{{
-
-    (setf  (gethash #\O table)
-           (list "          "
-                 "   _|_|   "
-                 " _|    _| "
-                 " _|    _| "
-                 " _|    _| "
-                 "   _|_|   "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; P {{{
-
-    (setf  (gethash #\P table)
-           (list "          "
-                 " _|_|_|   "
-                 " _|    _| "
-                 " _|_|_|   "
-                 " _|       "
-                 " _|       "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; Q {{{
-
-    (setf  (gethash #\Q table)
-           (list "            "
-                 "   _|_|     "
-                 " _|    _|   "
-                 " _|  _|_|   "
-                 " _|    _|   "
-                 "   _|_|  _| "
-                 "            "
-                 "            "))
-
-    ;; }}}
-    ;; R {{{
-
-    (setf  (gethash #\R table)
-           (list "          "
-                 " _|_|_|   "
-                 " _|    _| "
-                 " _|_|_|   "
-                 " _|    _| "
-                 " _|    _| "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; S {{{
-
-    (setf  (gethash #\S table)
-           (list "          "
-                 "   _|_|_| "
-                 " _|       "
-                 "   _|_|   "
-                 "       _| "
-                 " _|_|_|   "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; T {{{
-
-    (setf  (gethash #\T table)
-           (list "            "
-                 " _|_|_|_|_| "
-                 "     _|     "
-                 "     _|     "
-                 "     _|     "
-                 "     _|     "
-                 "            "
-                 "            "))
-
-    ;; }}}
-    ;; U {{{
-
-    (setf  (gethash #\U table)
-           (list "          "
-                 " _|    _| "
-                 " _|    _| "
-                 " _|    _| "
-                 " _|    _| "
-                 "   _|_|   "
-                 "          "
-                 "          "))
-
-    ;; }}}
-    ;; V {{{
-
-    (setf  (gethash #\V table)
-           (list "               "
-                 " _|         _| "
-                 "  _|       _|  "
-                 "   _|     _|   "
-                 "     _|  _|    "
-                 "       _|      "
-                 "               "
-                 "               "))
-
-    ;; }}}
-    ;; W {{{
-
-    (setf  (gethash #\W table)
-           (list "                "
-                 " _|          _| "
-                 " _|          _| "
-                 " _|    _|    _| "
-                 "   _|  _|  _|   "
-                 "     _|  _|     "
-                 "                "
-                 "                "))
-
-    ;; }}}
-    ;; X {{{
-
-    (setf  (gethash #\X table)
-           (list "            "
-                 " _|      _| "
-                 "   _|  _|   "
-                 "     _|     "
-                 "   _|  _|   "
-                 " _|      _| "
-                 "            "
-                 "            "))
-
-    ;; }}}
-    ;; Y {{{
-
-    (setf  (gethash #\Y table)
-           (list "            "
-                 " _|      _| "
-                 "   _|  _|   "
-                 "     _|     "
-                 "     _|     "
-                 "     _|     "
-                 "            "
-                 "            "))
-
-    ;; }}}
-    ;; Z {{{
-
-    (setf  (gethash #\Z table)
-           (list "            "
-                 " _|_|_|_|_| "
-                 "       _|   "
-                 "     _|     "
-                 "   _|       "
-                 " _|_|_|_|_| "
-                 "            "
-                 "            "))
-
-    ;; }}}
-    ;; }}}
-    ;; etc {{{
-    ;; . {{{
-
-    (setf (gethash #\. table)
-          (list "    "
-                "    "
-                "    "
-                "    "
-                "    "
-                " _| "
-                "    "
-                "    "))
-
-    ;; }}}
-    ;; ? {{{
-
-    (setf (gethash #\? table)
-          (list "        "
-                " _|_|   "
-                "     _| "
-                " _|_|   "
-                "        "
-                " _|     "
-                "        "
-                "        "))
-
-    ;; }}}
-    ;; ! {{{
-
-    (setf (gethash #\! table)
-          (list "    "
-                " _| "
-                " _| "
-                " _| "
-                "    "
-                " _| "
-                "    "
-                "    "))
-
-    ;; }}}
-    ;; - {{{
-
-    (setf (gethash #\- table)
-          (list "            "
-                "            "
-                "            "
-                " _|_|_|_|_| "
-                "            "
-                "            "
-                "            "
-                "            "))
-
-    ;; }}}
-    ;; #\Space  {{{
-
-    (setf (gethash #\Space table)
-          (list "    "
-                "    "
-                "    "
-                "    "
-                "    "
-                "    "
-                "    "
-                "    "))
-
-    ;; }}}
-    ;; }}}
-    table))
-
-(defparameter *print-table* (make-print-table))
-
-(defun char-list->print-lines (char-list &key (background nil))
-  (let ((result)
-        (line))
-    (dotimes (i 8)
-      (setq line (apply #'mkstr
-                        (mapcar (lambda (x)
-                                  (aif (nth i (gethash x *print-table*))
-                                    it
-                                    (error "char-list->print-lines: Unknown character `~A' to print" x)))
-                                char-list)))
-      (push (if background
-              (funcall #~s/ /${background}/g line)
-              line)
-            result))
-    (nreverse result)))
-
-(defun aprint (stream)
-  (with-output-to-string (out)
-    (awhile (read-line stream nil nil)
-      (let* ((print-lines (char-list->print-lines
-                            (coerce it 'list)
-                            :background *bg-character*))
-             (surround-line (if *surround-character*
-                              (make-string (length (first print-lines))
-                                           :initial-element *surround-character*)
-                              +empty-string+)))
-        (surround (princln surround-line out)
-          (dolist (i print-lines)
-            (princln  i out)))))))
-
+(require :stdlib *module-stdlib*)
+(require :regex *module-regex*)
+
+(defparameter *surround-character* nil)
+(defparameter *bg-character* #\Space)
+
+(defun make-print-table ()
+  (let ((table (make-hash-table :size 80)))
+    ;; number {{{
+    ;; 0 {{{
+
+    (setf (gethash #\0 table)
+          (list "        "
+                "   _|   "
+                " _|  _| "
+                " _|  _| "
+                " _|  _| "
+                "   _|   "
+                "        "
+                "        "))
+
+    ;; }}}
+    ;; 1 {{{
+
+    (setf (gethash #\1 table)
+          (list "        "
+                "   _|   "
+                " _|_|   "
+                "   _|   "
+                "   _|   "
+                "   _|   "
+                "        "
+                "        "))
+
+    ;; }}}
+    ;; 2 {{{
+
+    (setf (gethash #\2 table)
+          (list "          "
+                "   _|_|   "
+                " _|    _| "
+                "     _|   "
+                "   _|     "
+                " _|_|_|_| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; 3 {{{
+
+    (setf (gethash #\3 table)
+          (list "          "
+                " _|_|_|   "
+                "       _| "
+                "   _|_|   "
+                "       _| "
+                " _|_|_|   "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; 4 {{{
+
+    (setf (gethash #\4 table)
+          (list "          "
+                " _|  _|   "
+                " _|  _|   "
+                " _|_|_|_| "
+                "     _|   "
+                "     _|   "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; 5 {{{
+
+    (setf (gethash #\5 table)
+          (list "          "
+                " _|_|_|_| "
+                " _|       "
+                " _|_|_|   "
+                "       _| "
+                " _|_|_|   "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; 6 {{{
+
+    (setf (gethash #\6 table)
+          (list "          "
+                "   _|_|_| "
+                " _|       "
+                " _|_|_|   "
+                " _|    _| "
+                "   _|_|   "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; 7 {{{
+
+    (setf (gethash #\7 table)
+          (list "          "
+                " _|_|_|_| "
+                "      _|  "
+                "    _|    "
+                "   _|     "
+                "  _|      "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; 8 {{{
+
+    (setf (gethash #\8 table)
+          (list "          "
+                "   _|_|   "
+                " _|    _| "
+                "   _|_|   "
+                " _|    _| "
+                "   _|_|   "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; 9 {{{
+
+    (setf (gethash #\9 table)
+          (list "          "
+                "   _|_|   "
+                " _|    _| "
+                "   _|_|_| "
+                "       _| "
+                " _|_|_|   "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; }}}
+    ;; [a-z] {{{
+    ;; a {{{
+
+    (setf (gethash #\a table)
+          (list "          "
+                "          "
+                "   _|_|_| "
+                " _|    _| "
+                " _|    _| "
+                "   _|_|_| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; b {{{
+
+    (setf (gethash #\b table)
+          (list "          "
+                " _|       "
+                " _|_|_|   "
+                " _|    _| "
+                " _|    _| "
+                " _|_|_|   "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; c {{{
+
+    (setf (gethash #\c table)
+          (list "          "
+                "          "
+                "   _|_|_| "
+                " _|       "
+                " _|       "
+                "   _|_|_| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; d {{{
+
+    (setf (gethash #\d table)
+          (list "       _| "
+                "       _| "
+                "   _|_|_| "
+                " _|    _| "
+                " _|    _| "
+                "   _|_|_| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; e {{{
+
+    (setf (gethash #\e table)
+          (list "          "
+                "          "
+                "   _|_|   "
+                " _|_|_|_| "
+                " _|       "
+                "   _|_|_| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; f {{{
+
+    (setf (gethash #\f table)
+          (list "          "
+                "     _|_| "
+                "   _|     "
+                " _|_|_|_| "
+                "   _|     "
+                "   _|     "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; g {{{
+
+    (setf (gethash #\g table)
+          (list "          "
+                "          "
+                "   _|_|_| "
+                " _|    _| "
+                " _|    _| "
+                "   _|_|_| "
+                "       _| "
+                "   _|_|   "))
+
+    ;; }}}
+    ;; h {{{
+
+    (setf (gethash #\h table)
+          (list "          "
+                " _|       "
+                " _|_|_|   "
+                " _|    _| "
+                " _|    _| "
+                " _|    _| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; i {{{
+
+    (setf (gethash #\i table)
+          (list "     "
+                "  _| "
+                "     "
+                "  _| "
+                "  _| "
+                "  _| "
+                "     "
+                "     "))
+
+    ;; }}}
+    ;; i {{{
+
+    (setf (gethash #\j table)
+          (list "      "
+                "   _| "
+                "      "
+                "   _| "
+                "   _| "
+                "   _| "
+                "  _|  "
+                " _|   "))
+
+    ;; }}}
+    ;; k {{{
+
+    (setf (gethash #\k table)
+          (list "          "
+                " _|       "
+                " _|  _|   "
+                " _|_|     "
+                " _|  _|   "
+                " _|    _| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; l {{{
+
+    (setf (gethash #\l table)
+          (list "     "
+                "  _| "
+                "  _| "
+                "  _| "
+                "  _| "
+                "  _| "
+                "     "
+                "     "))
+
+    ;; }}}
+    ;; m {{{
+
+    (setf (gethash #\m table)
+          (list "              "
+                "              "
+                " _|_|_| _|_|  "
+                " _|   _|   _| "
+                " _|   _|   _| "
+                " _|   _|   _| "
+                "              "
+                "              "))
+
+    ;; }}}
+    ;; n {{{
+
+    (setf (gethash #\n table)
+          (list "          "
+                "          "
+                "  _|_|_|  "
+                " _|    _| "
+                " _|    _| "
+                " _|    _| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; o {{{
+
+    (setf (gethash #\o table)
+          (list "          "
+                "          "
+                "   _|_|   "
+                " _|    _| "
+                " _|    _| "
+                "   _|_|   "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; p {{{
+
+    (setf (gethash #\p table)
+          (list "          "
+                "          "
+                " _|_|_|   "
+                " _|    _| "
+                " _|    _| "
+                " _|_|_|   "
+                " _|       "
+                " _|       "))
+
+    ;; }}}
+    ;; p {{{
+
+    (setf (gethash #\q table)
+          (list "          "
+                "          "
+                "   _|_|_| "
+                " _|    _| "
+                " _|    _| "
+                "   _|_|_| "
+                "       _| "
+                "       _| "))
+
+    ;; }}}
+    ;; r {{{
+
+    (setf (gethash #\r table)
+          (list "          "
+                "          "
+                " _|  _|_| "
+                " _|_|     "
+                " _|       "
+                " _|       "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; s {{{
+
+    (setf (gethash #\s table)
+          (list "          "
+                "          "
+                "   _|_|_| "
+                " _|_|     "
+                "     _|_| "
+                " _|_|_|   "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; t {{{
+
+    (setf (gethash #\t table)
+          (list "          "
+                "   _|     "
+                " _|_|_|_| "
+                "   _|     "
+                "   _|     "
+                "     _|_| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; u {{{
+
+    (setf (gethash #\u table)
+          (list "          "
+                "          "
+                " _|    _| "
+                " _|    _| "
+                " _|    _| "
+                "   _|_|_| "
+                "          "
+                "          "))
+
+    ;; }}}
+    ;; v {{{
+
+    (setf (gethash #\v table)
+          (list "               "
+                "               "
+                "  _|        _| "
+                "   _|      _|  "
+                "     _|  _|    "
+                "       _|      "
+                "               "
+                "               "))
+
+    ;; }}}
+    ;; w {{{
+
+    (setf (gethash #\w table)
+          (list "                    "
+                "                    "
+                " _|      _|      _| "
+                "  _|     _|     _|  "
+                "   _|  _|  _|  _|   "
+                "     _|      _|     "
+                "                    "
+                "                    "))
+
+    ;; }}}
+    ;; x {{{
+
+    (setf (gethash #\x table)
+          (list "           "
+                "           "
+                "  _|    _| "
+                "    _|_|   "
+                "    _|_|   "
+                "  _|    _| "
+                "           "
+                "           "))
+
+    ;; }}}
+    ;; y {{{
+
+    (setf (gethash #\y table)
+          (list "          "
+                "          "
+                " _|    _| "
+                " _|    _| "
+                " _|    _| "
+                "   _|_|_| "
+                "       _| "
+                "   _|_|   "))
+
+    ;; }}}
+    ;; z {{{
+
+    (setf (gethash #\z table)
+          (list "           "
+                "           "
+                "  _|_|_|_| "
+                "      _|   "
+                "    _|     "
+                "  _|_|_|_| "
+                "           "
+                "           "))
+
+    ;; }}}
+    ;; }}}
+    ;; [A-Z] {{{
+    ;; A {{{
+
+    (setf  (gethash #\A table)
+           (list "          "
+                 "   _|_|   "
+                 " _|    _| "
+                 " _|_|_|_| "
+                 " _|    _| "
+                 " _|    _| "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; B {{{
+
+    (setf  (gethash #\B table)
+           (list "          "
+                 " _|_|_|   "
+                 " _|    _| "
+                 " _|_|_|   "
+                 " _|    _| "
+                 " _|_|_|   "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; C {{{
+
+    (setf  (gethash #\C table)
+           (list "          "
+                 "   _|_|_| "
+                 " _|       "
+                 " _|       "
+                 " _|       "
+                 "   _|_|_| "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; D {{{
+
+    (setf  (gethash #\D table)
+           (list "          "
+                 " _|_|_|   "
+                 " _|    _| "
+                 " _|    _| "
+                 " _|    _| "
+                 " _|_|_|   "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; E {{{
+
+    (setf  (gethash #\E table)
+           (list "          "
+                 " _|_|_|_| "
+                 " _|       "
+                 " _|_|_|   "
+                 " _|       "
+                 " _|_|_|_| "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; F {{{
+
+    (setf  (gethash #\F table)
+           (list "          "
+                 " _|_|_|_| "
+                 " _|       "
+                 " _|_|_|   "
+                 " _|       "
+                 " _|       "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; G {{{
+
+    (setf  (gethash #\G table)
+           (list "          "
+                 "   _|_|_| "
+                 " _|       "
+                 " _|  _|_| "
+                 " _|    _| "
+                 "   _|_|_| "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; H {{{
+
+    (setf  (gethash #\H table)
+           (list "          "
+                 " _|    _| "
+                 " _|    _| "
+                 " _|_|_|_| "
+                 " _|    _| "
+                 " _|    _| "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; I {{{
+
+    (setf  (gethash #\I table)
+           (list "        "
+                 " _|_|_| "
+                 "   _|   "
+                 "   _|   "
+                 "   _|   "
+                 " _|_|_| "
+                 "        "
+                 "        "))
+
+    ;; }}}
+    ;; J {{{
+
+    (setf  (gethash #\J table)
+           (list "          "
+                 "       _| "
+                 "       _| "
+                 "       _| "
+                 " _|    _| "
+                 "   _|_|   "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; K {{{
+
+    (setf  (gethash #\K table)
+           (list "          "
+                 " _|    _| "
+                 " _|  _|   "
+                 " _|_|     "
+                 " _|  _|   "
+                 " _|    _| "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; L {{{
+
+    (setf  (gethash #\L table)
+           (list "          "
+                 " _|       "
+                 " _|       "
+                 " _|       "
+                 " _|       "
+                 " _|_|_|_| "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; M {{{
+
+    (setf  (gethash #\M table)
+           (list "           "
+                 "_|      _| "
+                 "_|_|  _|_| "
+                 "_|  _|  _| "
+                 "_|      _| "
+                 "_|      _| "
+                 "           "
+                 "           "))
+
+    ;; }}}
+    ;; N {{{
+
+    (setf  (gethash #\N table)
+           (list "             "
+                 "  _|      _| "
+                 "  _|_|    _| "
+                 "  _|  _|  _| "
+                 "  _|    _|_| "
+                 "  _|      _| "
+                 "             "
+                 "             "))
+
+    ;; }}}
+    ;; O {{{
+
+    (setf  (gethash #\O table)
+           (list "          "
+                 "   _|_|   "
+                 " _|    _| "
+                 " _|    _| "
+                 " _|    _| "
+                 "   _|_|   "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; P {{{
+
+    (setf  (gethash #\P table)
+           (list "          "
+                 " _|_|_|   "
+                 " _|    _| "
+                 " _|_|_|   "
+                 " _|       "
+                 " _|       "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; Q {{{
+
+    (setf  (gethash #\Q table)
+           (list "            "
+                 "   _|_|     "
+                 " _|    _|   "
+                 " _|  _|_|   "
+                 " _|    _|   "
+                 "   _|_|  _| "
+                 "            "
+                 "            "))
+
+    ;; }}}
+    ;; R {{{
+
+    (setf  (gethash #\R table)
+           (list "          "
+                 " _|_|_|   "
+                 " _|    _| "
+                 " _|_|_|   "
+                 " _|    _| "
+                 " _|    _| "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; S {{{
+
+    (setf  (gethash #\S table)
+           (list "          "
+                 "   _|_|_| "
+                 " _|       "
+                 "   _|_|   "
+                 "       _| "
+                 " _|_|_|   "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; T {{{
+
+    (setf  (gethash #\T table)
+           (list "            "
+                 " _|_|_|_|_| "
+                 "     _|     "
+                 "     _|     "
+                 "     _|     "
+                 "     _|     "
+                 "            "
+                 "            "))
+
+    ;; }}}
+    ;; U {{{
+
+    (setf  (gethash #\U table)
+           (list "          "
+                 " _|    _| "
+                 " _|    _| "
+                 " _|    _| "
+                 " _|    _| "
+                 "   _|_|   "
+                 "          "
+                 "          "))
+
+    ;; }}}
+    ;; V {{{
+
+    (setf  (gethash #\V table)
+           (list "               "
+                 " _|         _| "
+                 "  _|       _|  "
+                 "   _|     _|   "
+                 "     _|  _|    "
+                 "       _|      "
+                 "               "
+                 "               "))
+
+    ;; }}}
+    ;; W {{{
+
+    (setf  (gethash #\W table)
+           (list "                "
+                 " _|          _| "
+                 " _|          _| "
+                 " _|    _|    _| "
+                 "   _|  _|  _|   "
+                 "     _|  _|     "
+                 "                "
+                 "                "))
+
+    ;; }}}
+    ;; X {{{
+
+    (setf  (gethash #\X table)
+           (list "            "
+                 " _|      _| "
+                 "   _|  _|   "
+                 "     _|     "
+                 "   _|  _|   "
+                 " _|      _| "
+                 "            "
+                 "            "))
+
+    ;; }}}
+    ;; Y {{{
+
+    (setf  (gethash #\Y table)
+           (list "            "
+                 " _|      _| "
+                 "   _|  _|   "
+                 "     _|     "
+                 "     _|     "
+                 "     _|     "
+                 "            "
+                 "            "))
+
+    ;; }}}
+    ;; Z {{{
+
+    (setf  (gethash #\Z table)
+           (list "            "
+                 " _|_|_|_|_| "
+                 "       _|   "
+                 "     _|     "
+                 "   _|       "
+                 " _|_|_|_|_| "
+                 "            "
+                 "            "))
+
+    ;; }}}
+    ;; }}}
+    ;; etc {{{
+    ;; . {{{
+
+    (setf (gethash #\. table)
+          (list "    "
+                "    "
+                "    "
+                "    "
+                "    "
+                " _| "
+                "    "
+                "    "))
+
+    ;; }}}
+    ;; ? {{{
+
+    (setf (gethash #\? table)
+          (list "        "
+                " _|_|   "
+                "     _| "
+                " _|_|   "
+                "        "
+                " _|     "
+                "        "
+                "        "))
+
+    ;; }}}
+    ;; ! {{{
+
+    (setf (gethash #\! table)
+          (list "    "
+                " _| "
+                " _| "
+                " _| "
+                "    "
+                " _| "
+                "    "
+                "    "))
+
+    ;; }}}
+    ;; - {{{
+
+    (setf (gethash #\- table)
+          (list "            "
+                "            "
+                "            "
+                " _|_|_|_|_| "
+                "            "
+                "            "
+                "            "
+                "            "))
+
+    ;; }}}
+    ;; #\Space  {{{
+
+    (setf (gethash #\Space table)
+          (list "    "
+                "    "
+                "    "
+                "    "
+                "    "
+                "    "
+                "    "
+                "    "))
+
+    ;; }}}
+    ;; }}}
+    table))
+
+(defparameter *print-table* (make-print-table))
+
+(defun char-list->print-lines (char-list &key (background nil))
+  (let ((result)
+        (line))
+    (dotimes (i 8)
+      (setq line (apply #'mkstr
+                        (mapcar (lambda (x)
+                                  (aif (nth i (gethash x *print-table*))
+                                    it
+                                    (error "char-list->print-lines: Unknown character `~A' to print" x)))
+                                char-list)))
+      (push (if background
+              (funcall #~s/ /${background}/g line)
+              line)
+            result))
+    (nreverse result)))
+
+(defun aprint (stream)
+  (with-output-to-string (out)
+    (awhile (read-line stream nil nil)
+      (let* ((print-lines (char-list->print-lines
+                            (coerce it 'list)
+                            :background *bg-character*))
+             (surround-line (if *surround-character*
+                              (make-string (length (first print-lines))
+                                           :initial-element *surround-character*)
+                              +empty-string+)))
+        (surround (princln surround-line out)
+          (dolist (i print-lines)
+            (princln  i out)))))))
diff --git a/bin/aprint/make.lisp b/bin/aprint/make.lisp
index 67549ed..fb7c339 100644
--- a/bin/aprint/make.lisp
+++ b/bin/aprint/make.lisp
@@ -1,4 +1,3 @@
-
 (load "aprint")
 
 (defexe aprint ((-s --surround-with) (-g --bg-char) --help)
@@ -18,4 +17,3 @@
         (with-input-from-string (in (list->string args #\Space))
           (aprint in))
         (aprint *standard-input*)))))
-
diff --git a/bin/ascii/ascii.lisp b/bin/ascii/ascii.lisp
index 8e80fd9..2e3c0fa 100644
--- a/bin/ascii/ascii.lisp
+++ b/bin/ascii/ascii.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defun ascii ()
@@ -12,4 +11,3 @@
       (format t "~%~2X-" (/ i 16)))
     (when (graphic-char-p (code-char i))
       (format t " ~A" (code-char i)))))
-
diff --git a/bin/ascii/make.lisp b/bin/ascii/make.lisp
index c206486..c3766ec 100644
--- a/bin/ascii/make.lisp
+++ b/bin/ascii/make.lisp
@@ -1,6 +1,4 @@
-
 (load "ascii")
 
 (defexe ascii ()
   (ascii))
-
diff --git a/bin/charcount.lisp b/bin/charcount.lisp
index fe9e703..e6065ea 100644
--- a/bin/charcount.lisp
+++ b/bin/charcount.lisp
@@ -1,4 +1,3 @@
-
 (load "../lib/stdlib")
 
 ;; count size of data from stdin
@@ -8,4 +7,3 @@
     (awhile (read-char *standard-input* nil nil)
       (incf count))
     (print count)))
-
diff --git a/bin/compute/compute.lisp b/bin/compute/compute.lisp
index bbd4bbd..0de28b5 100644
--- a/bin/compute/compute.lisp
+++ b/bin/compute/compute.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :ahead-reader *module-ahead-reader*)
 
@@ -100,4 +99,3 @@
   (with-ahead-reader (reader stream)
     (setq *tokens* (to-token reader)))
   (parse-expression))
-
diff --git a/bin/compute/make.lisp b/bin/compute/make.lisp
index 261bf73..6862654 100644
--- a/bin/compute/make.lisp
+++ b/bin/compute/make.lisp
@@ -1,4 +1,3 @@
-
 (load "compute")
 
 (defexe compute (--help)
@@ -13,4 +12,3 @@
         (with-input-from-string (in (list->string args #\Space))
           (compute in))
         (compute *standard-input*)))))
-
diff --git a/bin/compute/test.lisp b/bin/compute/test.lisp
index feb683f..9e893ee 100644
--- a/bin/compute/test.lisp
+++ b/bin/compute/test.lisp
@@ -1,4 +1,3 @@
-
 (load "compute")
 (require :test-utils *module-test-utils*)
 
@@ -47,4 +46,3 @@
    (test-calc "(1+2)*(3+4)")
    21)
   )
-
diff --git a/bin/copy.lisp b/bin/copy.lisp
index 45e0389..75373a8 100644
--- a/bin/copy.lisp
+++ b/bin/copy.lisp
@@ -1,8 +1,6 @@
-
 (load "../lib/stdlib")
 
 ;; copy input characters to output
 
 (defexe copy ()
   (stdout (stdin)))
-
diff --git a/bin/crypt.lisp b/bin/crypt.lisp
index e958b49..c7f93b2 100644
--- a/bin/crypt.lisp
+++ b/bin/crypt.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (let ((index 0)
@@ -43,4 +42,3 @@
        (funcall usage))
       (t
         (crypt-main key file)))))
-
diff --git a/bin/external-sort.lisp b/bin/external-sort.lisp
index 0950bca..1bce95e 100644
--- a/bin/external-sort.lisp
+++ b/bin/external-sort.lisp
@@ -1,4 +1,3 @@
-
 (load "../lib/stdlib")
 
 (defstruct sfile ()
@@ -53,4 +52,3 @@
                 (when (open-stream? (sfile-stream sfile))
                   (close (sfile-stream sfile))))
               sfiles))))
-
diff --git a/bin/head.lisp b/bin/head.lisp
index 4d4ed14..b55ae1e 100644
--- a/bin/head.lisp
+++ b/bin/head.lisp
@@ -1,4 +1,3 @@
-
 (load "../lib/stdlib")
 
 (defexe head ((-c --bytes) (-n --lines) (-q --quiet) (-v --verbose))
@@ -19,4 +18,3 @@
       (awhile (read-line *standard-input* nil nil)
         (echo it)))))
 
-
diff --git a/bin/left.lisp b/bin/left.lisp
index b900ca4..3fca13e 100644
--- a/bin/left.lisp
+++ b/bin/left.lisp
@@ -1,4 +1,3 @@
-
 (load "../lib/stdlib")
 
 (defun get-line (line columns)
@@ -28,4 +27,3 @@
             (mapcan (lambda (line)
                       (princln (get-line line columns)))
                     (read-from file))))))
-
diff --git a/bin/linecount.lisp b/bin/linecount.lisp
index 7beb9d8..b437fa1 100644
--- a/bin/linecount.lisp
+++ b/bin/linecount.lisp
@@ -1,4 +1,3 @@
-
 (load "../lib/stdlib")
 
 ;; count lines in standard input
@@ -8,4 +7,3 @@
     (awhile (read-line *standard-input* nil nil)
       (incf count))
     (print count)))
-
diff --git a/bin/translit.lisp b/bin/translit.lisp
index 5c5f859..bf97d1e 100644
--- a/bin/translit.lisp
+++ b/bin/translit.lisp
@@ -1,4 +1,3 @@
-
 (load "../lib/stdlib")
 
 (defun map-char (str index)
@@ -66,4 +65,3 @@
            (funcall usage))
           (t
             (translit-main from to lastto)))))
-
diff --git a/bin/xmltotext/make.lisp b/bin/xmltotext/make.lisp
index 94d68a9..990f821 100644
--- a/bin/xmltotext/make.lisp
+++ b/bin/xmltotext/make.lisp
@@ -1,4 +1,3 @@
-
 (load "xmltotext")
 
 (defexe xmltotext (--help)
@@ -8,4 +7,3 @@
     (when (or --help errors)
       (funcall usage))
     (main *standard-input*)))
-
diff --git a/bin/xmltotext/xmltotext.lisp b/bin/xmltotext/xmltotext.lisp
index 5b64009..3d16dba 100644
--- a/bin/xmltotext/xmltotext.lisp
+++ b/bin/xmltotext/xmltotext.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :xml-manager *module-xml-manager*)
 
@@ -17,4 +16,3 @@
 
 (defun main (stream)
   (get-text (parse-xml stream)))
-
diff --git a/doc/array.lisp b/doc/array.lisp
index 72d8b90..5d77105 100644
--- a/doc/array.lisp
+++ b/doc/array.lisp
@@ -1,414 +1,410 @@
-(load "../lib/stdlib")
-
-;; See Also: sequence.lisp
-
-;; simple vector (one-dimensional array)
-;; {{{
-
-(defparameter *vector* (make-array 4 :initial-element 'a))
-;;<=>
-(defparameter *vector* (vector 'a 'a 'a 'a))
-
-;; accesser
-(svref *vector* 0)    ; faster
-;;<=>
-(aref *vector* 0)
-;; => 'a
-
-;; }}}
-
-;; adjustable vector
-;; {{{
-
-(defparameter *vector* (make-array 5
-                                   :fill-pointer 0
-                                   :adjustable t
-                                   :element-type 'character))
-
-(vector-push #\a *vector*)
-*vector*
-;; => "a" 
-
-(vector-push #\b *vector*)
-(vector-push #\c *vector*)
-*vector*
-;; => "abc" 
-
-(vector-pop *vector*)
-*vector*
-;; =>"ab" 
-
-(vector-push-extend #\c *vector*)
-
-;;}}}
-
-;; two-dimensional array.
-;; {{{
-(defparameter *arr* (make-array '(2 3) :initial-element 0))
-
-;; accesser
-(aref *arr* 0 0)
-;; => 0
-
-;; substitute element.
-(setf (aref *arr* 0 1) 10)
-(aref *arr* 0 1)
-;; => 10 
-
-*arr*
-;; => #2a((0 10 0) (0 0 0))
-
-;; }}}
-
-
-;; Function MAKE-ARRAY {{{
-;; Syntax:
-;; make-array dimensions &key element-type initial-element initial-contents adjustable fill-pointer displaced-to displaced-index-offset
-;; => new-array
-;; 
-;; Arguments and Values:
-;; dimensions---a designator for a list of valid array dimensions.
-;; element-type---a type specifier. The default is t.
-;; initial-element---an object.
-;; initial-contents---an object.
-;; adjustable---a generalized boolean. The default is nil.
-;; fill-pointer---a valid fill pointer for the array to be created, or t or nil. The default is nil.
-;; displaced-to---an array or nil. The default is nil. This option must not be supplied if either initial-element or initial-contents is supplied.
-;; displaced-index-offset---a valid array row-major index for displaced-to. The default is 0. This option must not be supplied unless a non-nil displaced-to is supplied.
-;; new-array---an array.
-;; 
-;; Description:
-;; Creates and returns an array constructed of the most specialized type that can accommodate elements of type given by element-type. If dimensions is nil then a zero-dimensional array is created.
-;; Dimensions represents the dimensionality of the new array.
-;; element-type indicates the type of the elements intended to be stored in the new-array. The new-array can actually store any objects of the type which results from upgrading element-type; see Section 15.1.2.1 (Array Upgrading).
-;; If initial-element is supplied, it is used to initialize each element of new-array. If initial-element is supplied, it must be of the type given by element-type. initial-element cannot be supplied if either the :initial-contents option is supplied or displaced-to is non-nil. If initial-element is not supplied, the consequences of later reading an uninitialized element of new-array are undefined unless either initial-contents is supplied or displaced-to is non-nil.
-;; initial-contents is used to initialize the contents of array. For example:
-;;  (make-array '(4 2 3) :initial-contents
-;;              '(((a b c) (1 2 3))
-;;               ((d e f) (3 1 2))
-;;               ((g h i) (2 3 1))
-;;               ((j k l) (0 0 0))))
-;; initial-contents is composed of a nested structure of sequences. The numbers of levels in the structure must equal the rank of array. Each leaf of the nested structure must be of the type given by element-type. If array is zero-dimensional, then initial-contents specifies the single element. Otherwise, initial-contents must be a sequence whose length is equal to the first dimension; each element must be a nested structure for an array whose dimensions are the remaining dimensions, and so on. Initial-contents cannot be supplied if either initial-element is supplied or displaced-to is non-nil. If initial-contents is not supplied, the consequences of later reading an uninitialized element of new-array are undefined unless either initial-element is supplied or displaced-to is non-nil.
-;; If adjustable is non-nil, the array is expressly adjustable (and so actually adjustable); otherwise, the array is not expressly adjustable (and it is implementation-dependent whether the array is actually adjustable).
-;; If fill-pointer is non-nil, the array must be one-dimensional; that is, the array must be a vector. If fill-pointer is t, the length of the vector is used to initialize the fill pointer. If fill-pointer is an integer, it becomes the initial fill pointer for the vector.
-;; If displaced-to is non-nil, make-array will create a displaced array and displaced-to is the target of that displaced array. In that case, the consequences are undefined if the actual array element type of displaced-to is not type equivalent to the actual array element type of the array being created. If displaced-to is nil, the array is not a displaced array.
-;; The displaced-index-offset is made to be the index offset of the array. When an array A is given as the :displaced-to argument to make-array when creating array B, then array B is said to be displaced to array A. The total number of elements in an array, called the total size of the array, is calculated as the product of all the dimensions. It is required that the total size of A be no smaller than the sum of the total size of B plus the offset n supplied by the displaced-index-offset. The effect of displacing is that array B does not have any elements of its own, but instead maps accesses to itself into accesses to array A. The mapping treats both arrays as if they were one-dimensional by taking the elements in row-major order, and then maps an access to element k of array B to an access to element k+n of array A.
-;; If make-array is called with adjustable, fill-pointer, and displaced-to each nil, then the result is a simple array. If make-array is called with one or more of adjustable, fill-pointer, or displaced-to being true, whether the resulting array is a simple array is implementation-dependent.
-;; When an array A is given as the :displaced-to argument to make-array when creating array B, then array B is said to be displaced to array A. The total number of elements in an array, called the total size of the array, is calculated as the product of all the dimensions. The consequences are unspecified if the total size of A is smaller than the sum of the total size of B plus the offset n supplied by the displaced-index-offset. The effect of displacing is that array B does not have any elements of its own, but instead maps accesses to itself into accesses to array A. The mapping treats both arrays as if they were one-dimensional by taking the elements in row-major order, and then maps an access to element k of array B to an access to element k+n of array A.
-;; 
-;; Examples:
-;;  (make-array 5) ;; Creates a one-dimensional array of five elements.
-;;  (make-array '(3 4) :element-type '(mod 16)) ;; Creates a 
-;;                 ;;two-dimensional array, 3 by 4, with four-bit elements.
-;;  (make-array 5 :element-type 'single-float) ;; Creates an array of single-floats.
-;;  (make-array nil :initial-element nil) =>  #0ANIL
-;;  (make-array 4 :initial-element nil) =>  #(NIL NIL NIL NIL)
-;;  (make-array '(2 4) 
-;;               :element-type '(unsigned-byte 2) 
-;;               :initial-contents '((0 1 2 3) (3 2 1 0)))
-;; =>  #2A((0 1 2 3) (3 2 1 0))
-;;  (make-array 6
-;;               :element-type 'character 
-;;               :initial-element #\a 
-;;               :fill-pointer 3) =>  "aaa"
-;; The following is an example of making a displaced array.
-;;  (setq a (make-array '(4 3))) 
-;; =>  #<ARRAY 4x3 simple 32546632>
-;;  (dotimes (i 4)
-;;    (dotimes (j 3)
-;;      (setf (aref a i j) (list i 'x j '= (* i j)))))
-;; =>  NIL
-;;  (setq b (make-array 8 :displaced-to a
-;;                        :displaced-index-offset 2))
-;; =>  #<ARRAY 8 indirect 32550757>
-;;  (dotimes (i 8)
-;;    (print (list i (aref b i))))
-;; >>  (0 (0 X 2 = 0)) 
-;; >>  (1 (1 X 0 = 0)) 
-;; >>  (2 (1 X 1 = 1)) 
-;; >>  (3 (1 X 2 = 2)) 
-;; >>  (4 (2 X 0 = 0)) 
-;; >>  (5 (2 X 1 = 2)) 
-;; >>  (6 (2 X 2 = 4)) 
-;; >>  (7 (3 X 0 = 0)) 
-;; =>  NIL
-;; The last example depends on the fact that arrays are, in effect, stored in row-major order.
-;;  (setq a1 (make-array 50))
-;; =>  #<ARRAY 50 simple 32562043>
-;;  (setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))
-;; =>  #<ARRAY 20 indirect 32563346>
-;;  (length b1) =>  20
-;; 
-;;  (setq a2 (make-array 50 :fill-pointer 10))
-;; =>  #<ARRAY 50 fill-pointer 10 46100216>
-;;  (setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))
-;; =>  #<ARRAY 20 indirect 46104010>
-;;  (length a2) =>  10
-;;  (length b2) =>  20
-;; 
-;;  (setq a3 (make-array 50 :fill-pointer 10))
-;; =>  #<ARRAY 50 fill-pointer 10 46105663>
-;;  (setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10
-;;                          :fill-pointer 5))
-;; =>  #<ARRAY 20 indirect, fill-pointer 5 46107432>
-;;  (length a3) =>  10
-;;  (length b3) =>  5
-;; }}}
-;; Accessor AREF {{{
-;; 
-;; Syntax:
-;; aref array &rest subscripts => element
-;; (setf (aref array &rest subscripts) new-element)
-;; 
-;; Arguments and Values:
-;; array---an array.
-;; subscripts---a list of valid array indices for the array.
-;; element, new-element---an object.
-;; 
-;; Description:
-;; Accesses the array element specified by the subscripts. If no subscripts are supplied and array is zero rank, aref accesses the sole element of array.
-;; aref ignores fill pointers. It is permissible to use aref to access any array element, whether active or not.
-;; 
-;; Examples:
-;; If the variable foo names a 3-by-5 array, then the first index could be 0, 1, or 2, and then second index could be 0, 1, 2, 3, or 4. The array elements can be referred to by using the function aref; for example, (aref foo 2 1) refers to element (2, 1) of the array.
-;; 
-;;  (aref (setq alpha (make-array 4)) 3) =>  implementation-dependent
-;;  (setf (aref alpha 3) 'sirens) =>  SIRENS
-;;  (aref alpha 3) =>  SIRENS
-;;  (aref (setq beta (make-array '(2 4) 
-;;                     :element-type '(unsigned-byte 2)
-;;                     :initial-contents '((0 1 2 3) (3 2 1 0))))
-;;         1 2) =>  1
-;;  (setq gamma '(0 2))
-;;  (apply #'aref beta gamma) =>  2
-;;  (setf (apply #'aref beta gamma) 3) =>  3
-;;  (apply #'aref beta gamma) =>  3
-;;  (aref beta 0 2) =>  3
-;; }}}
-;; Function VECTOR {{{
-;;
-;; Syntax:
-;; vector &rest objects => vector
-;; 
-;; Arguments and Values:
-;; object---an object.
-;; vector---a vector of type (vector t *).
-;; 
-;; Description:
-;; Creates a fresh simple general vector whose size corresponds to the number of objects.
-;; The vector is initialized to contain the objects.
-;; 
-;; Examples:
-;; 
-;;  (arrayp (setq v (vector 1 2 'sirens))) =>  true
-;;  (vectorp v) =>  true
-;;  (simple-vector-p v) =>  true
-;;  (length v) =>  3
-;; 
-;; }}}
-;; Function VECTOR-PUSH, VECTOR-PUSH-EXTEND {{{
-;;
-;; Syntax:
-;; vector-push new-element vector => new-index-p
-;; vector-push-extend new-element vector &optional extension => new-index
-;; 
-;; Arguments and Values:
-;; new-element---an object.
-;; vector---a vector with a fill pointer.
-;; extension---a positive integer. The default is implementation-dependent.
-;; new-index-p---a valid array index for vector, or nil.
-;; new-index---a valid array index for vector.
-;; 
-;; Description:
-;; vector-push and vector-push-extend store new-element in vector. vector-push attempts to store new-element in the element of vector designated by the fill pointer, and to increase the fill pointer by one. If the (>= (fill-pointer vector) (array-dimension vector 0)), neither vector nor its fill pointer are affected. Otherwise, the store and increment take place and vector-push returns the former value of the fill pointer which is one less than the one it leaves in vector.
-;; vector-push-extend is just like vector-push except that if the fill pointer gets too large, vector is extended using adjust-array so that it can contain more elements. Extension is the minimum number of elements to be added to vector if it must be extended.
-;; vector-push and vector-push-extend return the index of new-element in vector. If (>= (fill-pointer vector) (array-dimension vector 0)), vector-push returns nil.
-;; 
-;; Examples:
-;;  (vector-push (setq fable (list 'fable))
-;;               (setq fa (make-array 8 
-;;                                    :fill-pointer 2
-;;                                    :initial-element 'first-one))) =>  2 
-;;  (fill-pointer fa) =>  3 
-;;  (eq (aref fa 2) fable) =>  true
-;;  (vector-push-extend #\X
-;;                     (setq aa 
-;;                           (make-array 5
-;;                                       :element-type 'character
-;;                                       :adjustable t
-;;                                       :fill-pointer 3))) =>  3 
-;;  (fill-pointer aa) =>  4 
-;;  (vector-push-extend #\Y aa 4) =>  4 
-;;  (array-total-size aa) =>  at least 5 
-;;  (vector-push-extend #\Z aa 4) =>  5 
-;;  (array-total-size aa) =>  9 ;(or more)
-;;
-;; }}}
-;; Function VECTOR-POP {{{
-;; 
-;; Syntax:
-;; vector-pop vector => element
-;; Arguments and Values:
-;; vector---a vector with a fill pointer.
-;; element---an object.
-;; 
-;; Description:
-;; Decreases the fill pointer of vector by one, and retrieves the element of vector that is designated by the new fill pointer.
-;; 
-;; Examples:
-;;  (vector-push (setq fable (list 'fable))
-;;               (setq fa (make-array 8
-;;                                    :fill-pointer 2
-;;                                    :initial-element 'sisyphus))) =>  2 
-;;  (fill-pointer fa) =>  3 
-;;  (eq (vector-pop fa) fable) =>  true
-;;  (vector-pop fa) =>  SISYPHUS 
-;;  (fill-pointer fa) =>  1 
-;;
-;; Side Effects:
-;; The fill pointer is decreased by one.
-;; 
-;; Affected By:
-;; The value of the fill pointer.
-;; 
-;; Exceptional Situations:
-;; An error of type type-error is signaled if vector does not have a fill pointer.
-;; If the fill pointer is zero, vector-pop signals an error of type error.
-;; 
-;; 
-;; }}}
-;; Accessor FILL-POINTER {{{
-;;
-;; Syntax:
-;; fill-pointer vector => fill-pointer
-;; (setf (fill-pointer vector) new-fill-pointer)
-;; Arguments and Values:
-;; vector---a vector with a fill pointer.
-;; fill-pointer, new-fill-pointer---a valid fill pointer for the vector.
-;; 
-;; Description:
-;; Accesses the fill pointer of vector.
-;; 
-;; Examples:
-;;  (setq a (make-array 8 :fill-pointer 4)) =>  #(NIL NIL NIL NIL)
-;;  (fill-pointer a) =>  4
-;;  (dotimes (i (length a)) (setf (aref a i) (* i i))) =>  NIL
-;;  a =>  #(0 1 4 9)
-;;  (setf (fill-pointer a) 3) =>  3
-;;  (fill-pointer a) =>  3
-;;  a =>  #(0 1 4)
-;;  (setf (fill-pointer a) 8) =>  8
-;;  a =>  #(0 1 4 9 NIL NIL NIL NIL)
-;;
-;; }}}
-;; Function ADJUST-ARRAY {{{
-;; 
-;; Syntax:
-;; adjust-array array new-dimensions &key element-type initial-element initial-contents fill-pointer displaced-to displaced-index-offset
-;; => adjusted-array
-;; 
-;; Arguments and Values:
-;; array---an array.
-;; new-dimensions---a valid array dimension or a list of valid array dimensions.
-;; element-type---a type specifier.
-;; initial-element---an object. Initial-element must not be supplied if either initial-contents or displaced-to is supplied.
-;; initial-contents---an object. If array has rank greater than zero, then initial-contents is composed of nested sequences, the depth of which must equal the rank of array. Otherwise, array is zero-dimensional and initial-contents supplies the single element. initial-contents must not be supplied if either initial-element or displaced-to is given.
-;; fill-pointer---a valid fill pointer for the array to be created, or t, or nil. The default is nil.
-;; displaced-to---an array or nil. initial-elements and initial-contents must not be supplied if displaced-to is supplied.
-;; displaced-index-offset---an object of type (fixnum 0 n) where n is (array-total-size displaced-to). displaced-index-offset may be supplied only if displaced-to is supplied.
-;; adjusted-array---an array.
-;; 
-;; Description:
-;; adjust-array changes the dimensions or elements of array. The result is an array of the same type and rank as array, that is either the modified array, or a newly created array to which array can be displaced, and that has the given new-dimensions.
-;; New-dimensions specify the size of each dimension of array.
-;; Element-type specifies the type of the elements of the resulting array. If element-type is supplied, the consequences are unspecified if the upgraded array element type of element-type is not the same as the actual array element type of array.
-;; If initial-contents is supplied, it is treated as for make-array. In this case none of the original contents of array appears in the resulting array.
-;; If fill-pointer is an integer, it becomes the fill pointer for the resulting array. If fill-pointer is the symbol t, it indicates that the size of the resulting array should be used as the fill pointer. If fill-pointer is nil, it indicates that the fill pointer should be left as it is.
-;; If displaced-to non-nil, a displaced array is created. The resulting array shares its contents with the array given by displaced-to. The resulting array cannot contain more elements than the array it is displaced to. If displaced-to is not supplied or nil, the resulting array is not a displaced array. If array A is created displaced to array B and subsequently array B is given to adjust-array, array A will still be displaced to array B. Although array might be a displaced array, the resulting array is not a displaced array unless displaced-to is supplied and not nil. The interaction between adjust-array and displaced arrays is as follows given three arrays, A, B, and C:
-;; 
-;; A is not displaced before or after the call
-;;  (adjust-array A ...)
-;; The dimensions of A are altered, and the contents rearranged as appropriate. Additional elements of A are taken from initial-element. The use of initial-contents causes all old contents to be discarded.
-;; 
-;; A is not displaced before, but is displaced to C after the call
-;;  (adjust-array A ... :displaced-to C)
-;; None of the original contents of A appears in A afterwards; A now contains the contents of C, without any rearrangement of C.
-;; 
-;; A is displaced to B before the call, and is displaced to C after the call
-;;  (adjust-array A ... :displaced-to B)
-;;  (adjust-array A ... :displaced-to C)
-;; B and C might be the same. The contents of B do not appear in A afterward unless such contents also happen to be in C If displaced-index-offset is not supplied in the adjust-array call, it defaults to zero; the old offset into B is not retained.
-;; 
-;; A is displaced to B before the call, but not displaced afterward.
-;;  (adjust-array A ... :displaced-to B)
-;;  (adjust-array A ... :displaced-to nil)
-;; A gets a new ``data region,'' and contents of B are copied into it as appropriate to maintain the existing old contents; additional elements of A are taken from initial-element if supplied. However, the use of initial-contents causes all old contents to be discarded.
-;; If displaced-index-offset is supplied, it specifies the offset of the resulting array from the beginning of the array that it is displaced to. If displaced-index-offset is not supplied, the offset is 0. The size of the resulting array plus the offset value cannot exceed the size of the array that it is displaced to.
-;; If only new-dimensions and an initial-element argument are supplied, those elements of array that are still in bounds appear in the resulting array. The elements of the resulting array that are not in the bounds of array are initialized to initial-element; if initial-element is not provided, the consequences of later reading any such new element of new-array before it has been initialized are undefined.
-;; If initial-contents or displaced-to is supplied, then none of the original contents of array appears in the new array.
-;; The consequences are unspecified if array is adjusted to a size smaller than its fill pointer without supplying the fill-pointer argument so that its fill-pointer is properly adjusted in the process.
-;; If A is displaced to B, the consequences are unspecified if B is adjusted in such a way that it no longer has enough elements to satisfy A.
-;; If adjust-array is applied to an array that is actually adjustable, the array returned is identical to array. If the array returned by adjust-array is distinct from array, then the argument array is unchanged.
-;; 
-;; Note that if an array A is displaced to another array B, and B is displaced to another array C, and B is altered by adjust-array, A must now refer to the adjust contents of B. This means that an implementation cannot collapse the chain to make A refer to C directly and forget that the chain of reference passes through B. However, caching techniques are permitted as long as they preserve the semantics specified here.
-;; 
-;; Examples:
-;;  (adjustable-array-p
-;;   (setq ada (adjust-array
-;;               (make-array '(2 3)
-;;                           :adjustable t
-;;                           :initial-contents '((a b c)
-;;                                               (1 2 3)))
-;;               '(4 6)))) =>  T 
-;;  (array-dimensions ada) =>  (4 6) 
-;;  (aref ada 1 1) =>  2 
-;;  (setq beta (make-array '(2 3) :adjustable t))
-;; =>  #2A((NIL NIL NIL) (NIL NIL NIL)) 
-;;  (adjust-array beta '(4 6) :displaced-to ada)
-;; =>  #2A((A B C NIL NIL NIL)
-;;        (1 2 3 NIL NIL NIL)
-;;        (NIL NIL NIL NIL NIL NIL) 
-;;        (NIL NIL NIL NIL NIL NIL))
-;;  (array-dimensions beta) =>  (4 6)
-;;  (aref beta 1 1) =>  2 
-;; Suppose that the 4-by-4 array in m looks like this:
-;; 
-;; #2A(( alpha     beta      gamma     delta )
-;;     ( epsilon   zeta      eta       theta )
-;;     ( iota      kappa     lambda    mu    )
-;;     ( nu        xi        omicron   pi    ))
-;; Then the result of
-;;  (adjust-array m '(3 5) :initial-element 'baz)
-;; is a 3-by-5 array with contents
-;; #2A(( alpha     beta      gamma     delta     baz )
-;;     ( epsilon   zeta      eta       theta     baz )
-;;     ( iota      kappa     lambda    mu        baz ))
-;;
-;; }}}
-;; Function ADJUSTABLE-ARRAY-P {{{
-;;
-;; Syntax:
-;; adjustable-array-p array => generalized-boolean
-;;
-;; Arguments and Values:
-;; array---an array.
-;; generalized-boolean---a generalized boolean.
-;;
-;; Description:
-;; Returns true if and only if adjust-array could return a value which is identical to array when given that array as its first argument.
-;; 
-;; Examples:
-;;  (adjustable-array-p 
-;;    (make-array 5
-;;                :element-type 'character 
-;;                :adjustable t 
-;;                :fill-pointer 3)) =>  true
-;;  (adjustable-array-p (make-array 4)) =>  implementation-dependent
-;;
-;; Exceptional Situations:
-;; Should signal an error of type type-error if its argument is not an array.
-;;
-;; }}}
-
-
-
+(load "../lib/stdlib")
+
+;; See Also: sequence.lisp
+
+;; simple vector (one-dimensional array)
+;; {{{
+
+(defparameter *vector* (make-array 4 :initial-element 'a))
+;;<=>
+(defparameter *vector* (vector 'a 'a 'a 'a))
+
+;; accesser
+(svref *vector* 0)    ; faster
+;;<=>
+(aref *vector* 0)
+;; => 'a
+
+;; }}}
+
+;; adjustable vector
+;; {{{
+
+(defparameter *vector* (make-array 5
+                                   :fill-pointer 0
+                                   :adjustable t
+                                   :element-type 'character))
+
+(vector-push #\a *vector*)
+*vector*
+;; => "a" 
+
+(vector-push #\b *vector*)
+(vector-push #\c *vector*)
+*vector*
+;; => "abc" 
+
+(vector-pop *vector*)
+*vector*
+;; =>"ab" 
+
+(vector-push-extend #\c *vector*)
+
+;;}}}
+
+;; two-dimensional array.
+;; {{{
+(defparameter *arr* (make-array '(2 3) :initial-element 0))
+
+;; accesser
+(aref *arr* 0 0)
+;; => 0
+
+;; substitute element.
+(setf (aref *arr* 0 1) 10)
+(aref *arr* 0 1)
+;; => 10 
+
+*arr*
+;; => #2a((0 10 0) (0 0 0))
+
+;; }}}
+
+;; Function MAKE-ARRAY {{{
+;; Syntax:
+;; make-array dimensions &key element-type initial-element initial-contents adjustable fill-pointer displaced-to displaced-index-offset
+;; => new-array
+;; 
+;; Arguments and Values:
+;; dimensions---a designator for a list of valid array dimensions.
+;; element-type---a type specifier. The default is t.
+;; initial-element---an object.
+;; initial-contents---an object.
+;; adjustable---a generalized boolean. The default is nil.
+;; fill-pointer---a valid fill pointer for the array to be created, or t or nil. The default is nil.
+;; displaced-to---an array or nil. The default is nil. This option must not be supplied if either initial-element or initial-contents is supplied.
+;; displaced-index-offset---a valid array row-major index for displaced-to. The default is 0. This option must not be supplied unless a non-nil displaced-to is supplied.
+;; new-array---an array.
+;; 
+;; Description:
+;; Creates and returns an array constructed of the most specialized type that can accommodate elements of type given by element-type. If dimensions is nil then a zero-dimensional array is created.
+;; Dimensions represents the dimensionality of the new array.
+;; element-type indicates the type of the elements intended to be stored in the new-array. The new-array can actually store any objects of the type which results from upgrading element-type; see Section 15.1.2.1 (Array Upgrading).
+;; If initial-element is supplied, it is used to initialize each element of new-array. If initial-element is supplied, it must be of the type given by element-type. initial-element cannot be supplied if either the :initial-contents option is supplied or displaced-to is non-nil. If initial-element is not supplied, the consequences of later reading an uninitialized element of new-array are undefined unless either initial-contents is supplied or displaced-to is non-nil.
+;; initial-contents is used to initialize the contents of array. For example:
+;;  (make-array '(4 2 3) :initial-contents
+;;              '(((a b c) (1 2 3))
+;;               ((d e f) (3 1 2))
+;;               ((g h i) (2 3 1))
+;;               ((j k l) (0 0 0))))
+;; initial-contents is composed of a nested structure of sequences. The numbers of levels in the structure must equal the rank of array. Each leaf of the nested structure must be of the type given by element-type. If array is zero-dimensional, then initial-contents specifies the single element. Otherwise, initial-contents must be a sequence whose length is equal to the first dimension; each element must be a nested structure for an array whose dimensions are the remaining dimensions, and so on. Initial-contents cannot be supplied if either initial-element is supplied or displaced-to is non-nil. If initial-contents is not supplied, the consequences of later reading an uninitialized element of new-array are undefined unless either initial-element is supplied or displaced-to is non-nil.
+;; If adjustable is non-nil, the array is expressly adjustable (and so actually adjustable); otherwise, the array is not expressly adjustable (and it is implementation-dependent whether the array is actually adjustable).
+;; If fill-pointer is non-nil, the array must be one-dimensional; that is, the array must be a vector. If fill-pointer is t, the length of the vector is used to initialize the fill pointer. If fill-pointer is an integer, it becomes the initial fill pointer for the vector.
+;; If displaced-to is non-nil, make-array will create a displaced array and displaced-to is the target of that displaced array. In that case, the consequences are undefined if the actual array element type of displaced-to is not type equivalent to the actual array element type of the array being created. If displaced-to is nil, the array is not a displaced array.
+;; The displaced-index-offset is made to be the index offset of the array. When an array A is given as the :displaced-to argument to make-array when creating array B, then array B is said to be displaced to array A. The total number of elements in an array, called the total size of the array, is calculated as the product of all the dimensions. It is required that the total size of A be no smaller than the sum of the total size of B plus the offset n supplied by the displaced-index-offset. The effect of displacing is that array B does not have any elements of its own, but instead maps accesses to itself into accesses to array A. The mapping treats both arrays as if they were one-dimensional by taking the elements in row-major order, and then maps an access to element k of array B to an access to element k+n of array A.
+;; If make-array is called with adjustable, fill-pointer, and displaced-to each nil, then the result is a simple array. If make-array is called with one or more of adjustable, fill-pointer, or displaced-to being true, whether the resulting array is a simple array is implementation-dependent.
+;; When an array A is given as the :displaced-to argument to make-array when creating array B, then array B is said to be displaced to array A. The total number of elements in an array, called the total size of the array, is calculated as the product of all the dimensions. The consequences are unspecified if the total size of A is smaller than the sum of the total size of B plus the offset n supplied by the displaced-index-offset. The effect of displacing is that array B does not have any elements of its own, but instead maps accesses to itself into accesses to array A. The mapping treats both arrays as if they were one-dimensional by taking the elements in row-major order, and then maps an access to element k of array B to an access to element k+n of array A.
+;; 
+;; Examples:
+;;  (make-array 5) ;; Creates a one-dimensional array of five elements.
+;;  (make-array '(3 4) :element-type '(mod 16)) ;; Creates a 
+;;                 ;;two-dimensional array, 3 by 4, with four-bit elements.
+;;  (make-array 5 :element-type 'single-float) ;; Creates an array of single-floats.
+;;  (make-array nil :initial-element nil) =>  #0ANIL
+;;  (make-array 4 :initial-element nil) =>  #(NIL NIL NIL NIL)
+;;  (make-array '(2 4) 
+;;               :element-type '(unsigned-byte 2) 
+;;               :initial-contents '((0 1 2 3) (3 2 1 0)))
+;; =>  #2A((0 1 2 3) (3 2 1 0))
+;;  (make-array 6
+;;               :element-type 'character 
+;;               :initial-element #\a 
+;;               :fill-pointer 3) =>  "aaa"
+;; The following is an example of making a displaced array.
+;;  (setq a (make-array '(4 3))) 
+;; =>  #<ARRAY 4x3 simple 32546632>
+;;  (dotimes (i 4)
+;;    (dotimes (j 3)
+;;      (setf (aref a i j) (list i 'x j '= (* i j)))))
+;; =>  NIL
+;;  (setq b (make-array 8 :displaced-to a
+;;                        :displaced-index-offset 2))
+;; =>  #<ARRAY 8 indirect 32550757>
+;;  (dotimes (i 8)
+;;    (print (list i (aref b i))))
+;; >>  (0 (0 X 2 = 0)) 
+;; >>  (1 (1 X 0 = 0)) 
+;; >>  (2 (1 X 1 = 1)) 
+;; >>  (3 (1 X 2 = 2)) 
+;; >>  (4 (2 X 0 = 0)) 
+;; >>  (5 (2 X 1 = 2)) 
+;; >>  (6 (2 X 2 = 4)) 
+;; >>  (7 (3 X 0 = 0)) 
+;; =>  NIL
+;; The last example depends on the fact that arrays are, in effect, stored in row-major order.
+;;  (setq a1 (make-array 50))
+;; =>  #<ARRAY 50 simple 32562043>
+;;  (setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))
+;; =>  #<ARRAY 20 indirect 32563346>
+;;  (length b1) =>  20
+;; 
+;;  (setq a2 (make-array 50 :fill-pointer 10))
+;; =>  #<ARRAY 50 fill-pointer 10 46100216>
+;;  (setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))
+;; =>  #<ARRAY 20 indirect 46104010>
+;;  (length a2) =>  10
+;;  (length b2) =>  20
+;; 
+;;  (setq a3 (make-array 50 :fill-pointer 10))
+;; =>  #<ARRAY 50 fill-pointer 10 46105663>
+;;  (setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10
+;;                          :fill-pointer 5))
+;; =>  #<ARRAY 20 indirect, fill-pointer 5 46107432>
+;;  (length a3) =>  10
+;;  (length b3) =>  5
+;; }}}
+;; Accessor AREF {{{
+;; 
+;; Syntax:
+;; aref array &rest subscripts => element
+;; (setf (aref array &rest subscripts) new-element)
+;; 
+;; Arguments and Values:
+;; array---an array.
+;; subscripts---a list of valid array indices for the array.
+;; element, new-element---an object.
+;; 
+;; Description:
+;; Accesses the array element specified by the subscripts. If no subscripts are supplied and array is zero rank, aref accesses the sole element of array.
+;; aref ignores fill pointers. It is permissible to use aref to access any array element, whether active or not.
+;; 
+;; Examples:
+;; If the variable foo names a 3-by-5 array, then the first index could be 0, 1, or 2, and then second index could be 0, 1, 2, 3, or 4. The array elements can be referred to by using the function aref; for example, (aref foo 2 1) refers to element (2, 1) of the array.
+;; 
+;;  (aref (setq alpha (make-array 4)) 3) =>  implementation-dependent
+;;  (setf (aref alpha 3) 'sirens) =>  SIRENS
+;;  (aref alpha 3) =>  SIRENS
+;;  (aref (setq beta (make-array '(2 4) 
+;;                     :element-type '(unsigned-byte 2)
+;;                     :initial-contents '((0 1 2 3) (3 2 1 0))))
+;;         1 2) =>  1
+;;  (setq gamma '(0 2))
+;;  (apply #'aref beta gamma) =>  2
+;;  (setf (apply #'aref beta gamma) 3) =>  3
+;;  (apply #'aref beta gamma) =>  3
+;;  (aref beta 0 2) =>  3
+;; }}}
+;; Function VECTOR {{{
+;;
+;; Syntax:
+;; vector &rest objects => vector
+;; 
+;; Arguments and Values:
+;; object---an object.
+;; vector---a vector of type (vector t *).
+;; 
+;; Description:
+;; Creates a fresh simple general vector whose size corresponds to the number of objects.
+;; The vector is initialized to contain the objects.
+;; 
+;; Examples:
+;; 
+;;  (arrayp (setq v (vector 1 2 'sirens))) =>  true
+;;  (vectorp v) =>  true
+;;  (simple-vector-p v) =>  true
+;;  (length v) =>  3
+;; 
+;; }}}
+;; Function VECTOR-PUSH, VECTOR-PUSH-EXTEND {{{
+;;
+;; Syntax:
+;; vector-push new-element vector => new-index-p
+;; vector-push-extend new-element vector &optional extension => new-index
+;; 
+;; Arguments and Values:
+;; new-element---an object.
+;; vector---a vector with a fill pointer.
+;; extension---a positive integer. The default is implementation-dependent.
+;; new-index-p---a valid array index for vector, or nil.
+;; new-index---a valid array index for vector.
+;; 
+;; Description:
+;; vector-push and vector-push-extend store new-element in vector. vector-push attempts to store new-element in the element of vector designated by the fill pointer, and to increase the fill pointer by one. If the (>= (fill-pointer vector) (array-dimension vector 0)), neither vector nor its fill pointer are affected. Otherwise, the store and increment take place and vector-push returns the former value of the fill pointer which is one less than the one it leaves in vector.
+;; vector-push-extend is just like vector-push except that if the fill pointer gets too large, vector is extended using adjust-array so that it can contain more elements. Extension is the minimum number of elements to be added to vector if it must be extended.
+;; vector-push and vector-push-extend return the index of new-element in vector. If (>= (fill-pointer vector) (array-dimension vector 0)), vector-push returns nil.
+;; 
+;; Examples:
+;;  (vector-push (setq fable (list 'fable))
+;;               (setq fa (make-array 8 
+;;                                    :fill-pointer 2
+;;                                    :initial-element 'first-one))) =>  2 
+;;  (fill-pointer fa) =>  3 
+;;  (eq (aref fa 2) fable) =>  true
+;;  (vector-push-extend #\X
+;;                     (setq aa 
+;;                           (make-array 5
+;;                                       :element-type 'character
+;;                                       :adjustable t
+;;                                       :fill-pointer 3))) =>  3 
+;;  (fill-pointer aa) =>  4 
+;;  (vector-push-extend #\Y aa 4) =>  4 
+;;  (array-total-size aa) =>  at least 5 
+;;  (vector-push-extend #\Z aa 4) =>  5 
+;;  (array-total-size aa) =>  9 ;(or more)
+;;
+;; }}}
+;; Function VECTOR-POP {{{
+;; 
+;; Syntax:
+;; vector-pop vector => element
+;; Arguments and Values:
+;; vector---a vector with a fill pointer.
+;; element---an object.
+;; 
+;; Description:
+;; Decreases the fill pointer of vector by one, and retrieves the element of vector that is designated by the new fill pointer.
+;; 
+;; Examples:
+;;  (vector-push (setq fable (list 'fable))
+;;               (setq fa (make-array 8
+;;                                    :fill-pointer 2
+;;                                    :initial-element 'sisyphus))) =>  2 
+;;  (fill-pointer fa) =>  3 
+;;  (eq (vector-pop fa) fable) =>  true
+;;  (vector-pop fa) =>  SISYPHUS 
+;;  (fill-pointer fa) =>  1 
+;;
+;; Side Effects:
+;; The fill pointer is decreased by one.
+;; 
+;; Affected By:
+;; The value of the fill pointer.
+;; 
+;; Exceptional Situations:
+;; An error of type type-error is signaled if vector does not have a fill pointer.
+;; If the fill pointer is zero, vector-pop signals an error of type error.
+;; 
+;; 
+;; }}}
+;; Accessor FILL-POINTER {{{
+;;
+;; Syntax:
+;; fill-pointer vector => fill-pointer
+;; (setf (fill-pointer vector) new-fill-pointer)
+;; Arguments and Values:
+;; vector---a vector with a fill pointer.
+;; fill-pointer, new-fill-pointer---a valid fill pointer for the vector.
+;; 
+;; Description:
+;; Accesses the fill pointer of vector.
+;; 
+;; Examples:
+;;  (setq a (make-array 8 :fill-pointer 4)) =>  #(NIL NIL NIL NIL)
+;;  (fill-pointer a) =>  4
+;;  (dotimes (i (length a)) (setf (aref a i) (* i i))) =>  NIL
+;;  a =>  #(0 1 4 9)
+;;  (setf (fill-pointer a) 3) =>  3
+;;  (fill-pointer a) =>  3
+;;  a =>  #(0 1 4)
+;;  (setf (fill-pointer a) 8) =>  8
+;;  a =>  #(0 1 4 9 NIL NIL NIL NIL)
+;;
+;; }}}
+;; Function ADJUST-ARRAY {{{
+;; 
+;; Syntax:
+;; adjust-array array new-dimensions &key element-type initial-element initial-contents fill-pointer displaced-to displaced-index-offset
+;; => adjusted-array
+;; 
+;; Arguments and Values:
+;; array---an array.
+;; new-dimensions---a valid array dimension or a list of valid array dimensions.
+;; element-type---a type specifier.
+;; initial-element---an object. Initial-element must not be supplied if either initial-contents or displaced-to is supplied.
+;; initial-contents---an object. If array has rank greater than zero, then initial-contents is composed of nested sequences, the depth of which must equal the rank of array. Otherwise, array is zero-dimensional and initial-contents supplies the single element. initial-contents must not be supplied if either initial-element or displaced-to is given.
+;; fill-pointer---a valid fill pointer for the array to be created, or t, or nil. The default is nil.
+;; displaced-to---an array or nil. initial-elements and initial-contents must not be supplied if displaced-to is supplied.
+;; displaced-index-offset---an object of type (fixnum 0 n) where n is (array-total-size displaced-to). displaced-index-offset may be supplied only if displaced-to is supplied.
+;; adjusted-array---an array.
+;; 
+;; Description:
+;; adjust-array changes the dimensions or elements of array. The result is an array of the same type and rank as array, that is either the modified array, or a newly created array to which array can be displaced, and that has the given new-dimensions.
+;; New-dimensions specify the size of each dimension of array.
+;; Element-type specifies the type of the elements of the resulting array. If element-type is supplied, the consequences are unspecified if the upgraded array element type of element-type is not the same as the actual array element type of array.
+;; If initial-contents is supplied, it is treated as for make-array. In this case none of the original contents of array appears in the resulting array.
+;; If fill-pointer is an integer, it becomes the fill pointer for the resulting array. If fill-pointer is the symbol t, it indicates that the size of the resulting array should be used as the fill pointer. If fill-pointer is nil, it indicates that the fill pointer should be left as it is.
+;; If displaced-to non-nil, a displaced array is created. The resulting array shares its contents with the array given by displaced-to. The resulting array cannot contain more elements than the array it is displaced to. If displaced-to is not supplied or nil, the resulting array is not a displaced array. If array A is created displaced to array B and subsequently array B is given to adjust-array, array A will still be displaced to array B. Although array might be a displaced array, the resulting array is not a displaced array unless displaced-to is supplied and not nil. The interaction between adjust-array and displaced arrays is as follows given three arrays, A, B, and C:
+;; 
+;; A is not displaced before or after the call
+;;  (adjust-array A ...)
+;; The dimensions of A are altered, and the contents rearranged as appropriate. Additional elements of A are taken from initial-element. The use of initial-contents causes all old contents to be discarded.
+;; 
+;; A is not displaced before, but is displaced to C after the call
+;;  (adjust-array A ... :displaced-to C)
+;; None of the original contents of A appears in A afterwards; A now contains the contents of C, without any rearrangement of C.
+;; 
+;; A is displaced to B before the call, and is displaced to C after the call
+;;  (adjust-array A ... :displaced-to B)
+;;  (adjust-array A ... :displaced-to C)
+;; B and C might be the same. The contents of B do not appear in A afterward unless such contents also happen to be in C If displaced-index-offset is not supplied in the adjust-array call, it defaults to zero; the old offset into B is not retained.
+;; 
+;; A is displaced to B before the call, but not displaced afterward.
+;;  (adjust-array A ... :displaced-to B)
+;;  (adjust-array A ... :displaced-to nil)
+;; A gets a new ``data region,'' and contents of B are copied into it as appropriate to maintain the existing old contents; additional elements of A are taken from initial-element if supplied. However, the use of initial-contents causes all old contents to be discarded.
+;; If displaced-index-offset is supplied, it specifies the offset of the resulting array from the beginning of the array that it is displaced to. If displaced-index-offset is not supplied, the offset is 0. The size of the resulting array plus the offset value cannot exceed the size of the array that it is displaced to.
+;; If only new-dimensions and an initial-element argument are supplied, those elements of array that are still in bounds appear in the resulting array. The elements of the resulting array that are not in the bounds of array are initialized to initial-element; if initial-element is not provided, the consequences of later reading any such new element of new-array before it has been initialized are undefined.
+;; If initial-contents or displaced-to is supplied, then none of the original contents of array appears in the new array.
+;; The consequences are unspecified if array is adjusted to a size smaller than its fill pointer without supplying the fill-pointer argument so that its fill-pointer is properly adjusted in the process.
+;; If A is displaced to B, the consequences are unspecified if B is adjusted in such a way that it no longer has enough elements to satisfy A.
+;; If adjust-array is applied to an array that is actually adjustable, the array returned is identical to array. If the array returned by adjust-array is distinct from array, then the argument array is unchanged.
+;; 
+;; Note that if an array A is displaced to another array B, and B is displaced to another array C, and B is altered by adjust-array, A must now refer to the adjust contents of B. This means that an implementation cannot collapse the chain to make A refer to C directly and forget that the chain of reference passes through B. However, caching techniques are permitted as long as they preserve the semantics specified here.
+;; 
+;; Examples:
+;;  (adjustable-array-p
+;;   (setq ada (adjust-array
+;;               (make-array '(2 3)
+;;                           :adjustable t
+;;                           :initial-contents '((a b c)
+;;                                               (1 2 3)))
+;;               '(4 6)))) =>  T 
+;;  (array-dimensions ada) =>  (4 6) 
+;;  (aref ada 1 1) =>  2 
+;;  (setq beta (make-array '(2 3) :adjustable t))
+;; =>  #2A((NIL NIL NIL) (NIL NIL NIL)) 
+;;  (adjust-array beta '(4 6) :displaced-to ada)
+;; =>  #2A((A B C NIL NIL NIL)
+;;        (1 2 3 NIL NIL NIL)
+;;        (NIL NIL NIL NIL NIL NIL) 
+;;        (NIL NIL NIL NIL NIL NIL))
+;;  (array-dimensions beta) =>  (4 6)
+;;  (aref beta 1 1) =>  2 
+;; Suppose that the 4-by-4 array in m looks like this:
+;; 
+;; #2A(( alpha     beta      gamma     delta )
+;;     ( epsilon   zeta      eta       theta )
+;;     ( iota      kappa     lambda    mu    )
+;;     ( nu        xi        omicron   pi    ))
+;; Then the result of
+;;  (adjust-array m '(3 5) :initial-element 'baz)
+;; is a 3-by-5 array with contents
+;; #2A(( alpha     beta      gamma     delta     baz )
+;;     ( epsilon   zeta      eta       theta     baz )
+;;     ( iota      kappa     lambda    mu        baz ))
+;;
+;; }}}
+;; Function ADJUSTABLE-ARRAY-P {{{
+;;
+;; Syntax:
+;; adjustable-array-p array => generalized-boolean
+;;
+;; Arguments and Values:
+;; array---an array.
+;; generalized-boolean---a generalized boolean.
+;;
+;; Description:
+;; Returns true if and only if adjust-array could return a value which is identical to array when given that array as its first argument.
+;; 
+;; Examples:
+;;  (adjustable-array-p 
+;;    (make-array 5
+;;                :element-type 'character 
+;;                :adjustable t 
+;;                :fill-pointer 3)) =>  true
+;;  (adjustable-array-p (make-array 4)) =>  implementation-dependent
+;;
+;; Exceptional Situations:
+;; Should signal an error of type type-error if its argument is not an array.
+;;
+;; }}}
diff --git a/doc/char.lisp b/doc/char.lisp
index 3b24173..f105e0c 100644
--- a/doc/char.lisp
+++ b/doc/char.lisp
@@ -1,5 +1,3 @@
-
-
 ;; Accessor CHAR, SCHAR {{{
 ;; Syntax:
 ;; char string index => character
@@ -325,5 +323,3 @@
 ;;  ;; in which #\Bell is an implementation-defined character.
 ;;  (lower-case-p #\Bell) =>  false
 ;; }}}
-
-
diff --git a/doc/class.lisp b/doc/class.lisp
index 6949d5d..ed3b656 100644
--- a/doc/class.lisp
+++ b/doc/class.lisp
@@ -1,4 +1,3 @@
-
 ;; define
 (defclass circle()
   (radius center))
@@ -45,13 +44,6 @@
 (print (circle-num c2))
 ;; => 2
 
-
-
-
-
-
-
-
 ;; point
 ;; @see structure.lisp
 (defclass point ()
@@ -102,7 +94,3 @@
   (area c))
 ;; => 6 
 ;; => 78.53981633974483096L0 
-
-
-
-
diff --git a/doc/environment.lisp b/doc/environment.lisp
index acddb67..a9d24cf 100644
--- a/doc/environment.lisp
+++ b/doc/environment.lisp
@@ -1,4 +1,3 @@
-
 (machine-instance)
 (machine-type)
 (machine-version)
@@ -7,4 +6,3 @@
 (lisp-implementation-type)
 (lisp-implementation-version)
 (user-homedir-pathname)
-
diff --git a/doc/eq.lisp b/doc/eq.lisp
index ceee7d3..bcaf994 100644
--- a/doc/eq.lisp
+++ b/doc/eq.lisp
@@ -1,5 +1,3 @@
-
-
 ;; Function EQ  {{{
 ;; 
 ;; 
@@ -302,5 +300,3 @@
 ;; Object equality is not a concept for which there is a uniquely determined correct algorithm. The appropriateness of an equality predicate can be judged only in the context of the needs of some particular program. Although these functions take any type of argument and their names sound very generic, equal and equalp are not appropriate for every application. 
 ;;
 ;; }}}
-
-
diff --git a/doc/format.lisp b/doc/format.lisp
index a75011f..0e01a35 100644
--- a/doc/format.lisp
+++ b/doc/format.lisp
@@ -1,4 +1,3 @@
-
 ;; Basic Output
 ;; {{{
 
@@ -188,4 +187,3 @@
 ;; =>   "FOO   BAR   BAZ"
 
 ;;}}}
-
diff --git a/doc/hash-table.lisp b/doc/hash-table.lisp
index c648f22..2e9e653 100644
--- a/doc/hash-table.lisp
+++ b/doc/hash-table.lisp
@@ -1,251 +1,249 @@
-(load "../lib/stdlib")
-
-(defparameter ht (make-hash-table))
-
-(gethash 'color ht)
-;; => NIL
-;;    NIL
-
-(setf (gethash 'color ht) 'red)
-;; => RED
-
-(gethash 'color ht)
-;; => RED
-;;    T
-
-(push 'dog (gethash 'animal ht))
-;; => DOG
-
-(gethash 'animal ht)
-;; => DOG
-;;    T
-
-(remhash 'animal ht)
-;; => T
-
-(remhash 'animal ht)
-;; => NIL
-
-(setf (gethash 'shape ht) 'spherical
-      (gethash 'size ht) 'giant)
-;; => GIANT
-
-(maphash (lambda (k v)
-           (format t "~A = ~A~%" k v))
-         ht)
-;; => SIZE = GIANT
-;;    SHAPE = SPHERICAL
-;;    COLOR = RED
-
-(clrhash ht)
-
-(dotimes (i 100)
-  (setf (gethash i ht) (* i i)))
-
-(dotimes (i (hash-table-count ht))
-  (print (gethash i ht)))
-
-
-;; Function MAKE-HASH-TABLE {{{
-;;
-;; Syntax:
-;; make-hash-table &key test size rehash-size rehash-threshold => hash-table
-;; Arguments and Values:
-;; test---a designator for one of the functions eq, eql, equal, or equalp. The default is eql.
-;; size---a non-negative integer. The default is implementation-dependent.
-;; rehash-size---a real of type (or (integer 1 *) (float (1.0) *)). The default is implementation-dependent.
-;; rehash-threshold---a real of type (real 0 1). The default is implementation-dependent.
-;; hash-table---a hash table.
-;; 
-;; Description:
-;; Creates and returns a new hash table.
-;; test determines how keys are compared. An object is said to be present in the hash-table if that object is the same under the test as the key for some entry in the hash-table.
-;; size is a hint to the implementation about how much initial space to allocate in the hash-table. This information, taken together with the rehash-threshold, controls the approximate number of entries which it should be possible to insert before the table has to grow. The actual size might be rounded up from size to the next `good' size; for example, some implementations might round to the next prime number.
-;; rehash-size specifies a minimum amount to increase the size of the hash-table when it becomes full enough to require rehashing; see rehash-theshold below. If rehash-size is an integer, the expected growth rate for the table is additive and the integer is the number of entries to add; if it is a float, the expected growth rate for the table is multiplicative and the float is the ratio of the new size to the old size. As with size, the actual size of the increase might be rounded up.
-;; rehash-threshold specifies how full the hash-table can get before it must grow. It specifies the maximum desired hash-table occupancy level.
-;; The values of rehash-size and rehash-threshold do not constrain the implementation to use any particular method for computing when and by how much the size of hash-table should be enlarged. Such decisions are implementation-dependent, and these values only hints from the programmer to the implementation, and the implementation is permitted to ignore them.
-;; 
-;; Examples:
-;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 46142754>
-;;  (setf (gethash "one" table) 1) =>  1
-;;  (gethash "one" table) =>  NIL, false
-;;  (setq table (make-hash-table :test 'equal)) =>  #<HASH-TABLE EQUAL 0/139 46145547>
-;;  (setf (gethash "one" table) 1) =>  1
-;;  (gethash "one" table) =>  1, T
-;;  (make-hash-table :rehash-size 1.5 :rehash-threshold 0.7) 
-;; =>  #<HASH-TABLE EQL 0/120 46156620>
-;; }}}
-;; Function HASH-TABLE-COUNT {{{
-;; 
-;; Syntax:
-;; hash-table-count hash-table => count
-;; Arguments and Values:
-;; hash-table---a hash table.
-;; count---a non-negative integer.
-;; 
-;; Description:
-;; Returns the number of entries in the hash-table. If hash-table has just been created or newly cleared (see clrhash) the entry count is 0.
-;; 
-;; Examples:
-;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32115135>
-;;  (hash-table-count table) =>  0
-;;  (setf (gethash 57 table) "fifty-seven") =>  "fifty-seven"
-;;  (hash-table-count table) =>  1
-;;  (dotimes (i 100) (setf (gethash i table) i)) =>  NIL
-;;  (hash-table-count table) =>  100
-;; Side Effects: None.
-;; 
-;; Notes:
-;; 
-;; The following relationships are functionally correct, although in practice using hash-table-count is probably much faster:
-;; 
-;;  (hash-table-count table) == 
-;;  (loop for value being the hash-values of table count t) == 
-;;  (let ((total 0))
-;;    (maphash #'(lambda (key value)
-;;                 (declare (ignore key value))
-;;                 (incf total))
-;;             table)
-;;    total)
-;; }}}
-;; Function HASH-TABLE-SIZE {{{
-;;
-;; Syntax:
-;; hash-table-size hash-table => size
-;; 
-;; Arguments and Values:
-;; hash-table---a hash table.
-;; size---a non-negative integer.
-;; 
-;; Description:
-;; Returns the current size of hash-table,
-;; which is suitable for use in a call to make-hash-table in order to produce a hash table with state corresponding to the current state of the hash-table.
-;; 
-;; 
-;; Exceptional Situations:
-;; Should signal an error of type type-error if hash-table is not a hash table.
-;; 
-;; 
-;; }}}
-;; Function CLRHASH {{{
-;; 
-;; Syntax:
-;; clrhash hash-table => hash-table
-;; 
-;; Arguments and Values:
-;; hash-table---a hash table.
-;; 
-;; Description:
-;; Removes all entries from hash-table, and then returns that empty hash table.
-;; 
-;; Examples:
-;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32004073>
-;;  (dotimes (i 100) (setf (gethash i table) (format nil "~R" i))) =>  NIL
-;;  (hash-table-count table) =>  100
-;;  (gethash 57 table) =>  "fifty-seven", true
-;;  (clrhash table) =>  #<HASH-TABLE EQL 0/120 32004073>
-;;  (hash-table-count table) =>  0
-;;  (gethash 57 table) =>  NIL, false
-;;
-;; }}}
-;; Accessor GETHASH {{{
-;; 
-;; Syntax:
-;; gethash key hash-table &optional default => value, present-p
-;; (setf (gethash key hash-table &optional default) new-value)
-;; 
-;; Arguments and Values:
-;; key---an object.
-;; hash-table---a hash table.
-;; default---an object. The default is nil.
-;; value---an object.
-;; present-p---a generalized boolean.
-;; 
-;; Description:
-;; Value is the object in hash-table whose key is the same as key under the hash-table's equivalence test. If there is no such entry, value is the default.
-;; Present-p is true if an entry is found; otherwise, it is false.
-;; setf may be used with gethash to modify the value associated with a given key, or to add a new entry. When a gethash form is used as a setf place, any default which is supplied is evaluated according to normal left-to-right evaluation rules, but its value is ignored.
-;; 
-;; Examples:
-;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32206334>
-;;  (gethash 1 table) =>  NIL, false
-;;  (gethash 1 table 2) =>  2, false
-;;  (setf (gethash 1 table) "one") =>  "one"
-;;  (setf (gethash 2 table "two") "two") =>  "two"
-;;  (gethash 1 table) =>  "one", true
-;;  (gethash 2 table) =>  "two", true
-;;  (gethash nil table) =>  NIL, false
-;;  (setf (gethash nil table) nil) =>  NIL 
-;;  (gethash nil table) =>  NIL, true
-;;  (defvar *counters* (make-hash-table)) =>  *COUNTERS*
-;;  (gethash 'foo *counters*) =>  NIL, false
-;;  (gethash 'foo *counters* 0) =>  0, false
-;;  (defmacro how-many (obj) `(values (gethash ,obj *counters* 0))) =>  HOW-MANY
-;;  (defun count-it (obj) (incf (how-many obj))) =>  COUNT-IT
-;;  (dolist (x '(bar foo foo bar bar baz)) (count-it x))
-;;  (how-many 'foo) =>  2
-;;  (how-many 'bar) =>  3
-;;  (how-many 'quux) =>  0
-;; 
-;; }}}
-;; Function REMHASH {{{
-;;
-;; Syntax:
-;; remhash key hash-table => generalized-boolean
-;;
-;; Arguments and Values:
-;; key---an object.
-;; hash-table---a hash table.
-;; generalized-boolean---a generalized boolean.
-;;
-;; Description:
-;; Removes the entry for key in hash-table, if any. Returns true if there was such an entry, or false otherwise.
-;;
-;; Examples:
-;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32115666>
-;;  (setf (gethash 100 table) "C") =>  "C"
-;;  (gethash 100 table) =>  "C", true
-;;  (remhash 100 table) =>  true
-;;  (gethash 100 table) =>  NIL, false
-;;  (remhash 100 table) =>  false
-;;
-;; }}}
-;; Function MAPHASH {{{
-;; 
-;; Syntax:
-;; maphash function hash-table => nil
-;; 
-;; Arguments and Values:
-;; function---a designator for a function of two arguments, the key and the value.
-;; hash-table---a hash table.
-;; 
-;; Description:
-;; Iterates over all entries in the hash-table. For each entry, the function is called with two arguments--the key and the value of that entry.
-;; The consequences are unspecified if any attempt is made to add or remove an entry from the hash-table while a maphash is in progress, with two exceptions: the function can use can use setf of gethash to change the value part of the entry currently being processed, or it can use remhash to remove that entry.
-;; 
-;; Examples:
-;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32304110>
-;;  (dotimes (i 10) (setf (gethash i table) i)) =>  NIL
-;;  (let ((sum-of-squares 0))
-;;     (maphash #'(lambda (key val) 
-;;                  (let ((square (* val val)))
-;;                    (incf sum-of-squares square)
-;;                    (setf (gethash key table) square)))
-;;              table)
-;;     sum-of-squares) =>  285
-;;  (hash-table-count table) =>  10
-;;  (maphash #'(lambda (key val)
-;;                (when (oddp val) (remhash key table)))
-;;            table) =>  NIL
-;;  (hash-table-count table) =>  5
-;;  (maphash #'(lambda (k v) (print (list k v))) table)
-;; (0 0) 
-;; (8 64) 
-;; (2 4) 
-;; (6 36) 
-;; (4 16) 
-;; =>  NIL
-;; 
-;; }}}
-
-
+(load "../lib/stdlib")
+
+(defparameter ht (make-hash-table))
+
+(gethash 'color ht)
+;; => NIL
+;;    NIL
+
+(setf (gethash 'color ht) 'red)
+;; => RED
+
+(gethash 'color ht)
+;; => RED
+;;    T
+
+(push 'dog (gethash 'animal ht))
+;; => DOG
+
+(gethash 'animal ht)
+;; => DOG
+;;    T
+
+(remhash 'animal ht)
+;; => T
+
+(remhash 'animal ht)
+;; => NIL
+
+(setf (gethash 'shape ht) 'spherical
+      (gethash 'size ht) 'giant)
+;; => GIANT
+
+(maphash (lambda (k v)
+           (format t "~A = ~A~%" k v))
+         ht)
+;; => SIZE = GIANT
+;;    SHAPE = SPHERICAL
+;;    COLOR = RED
+
+(clrhash ht)
+
+(dotimes (i 100)
+  (setf (gethash i ht) (* i i)))
+
+(dotimes (i (hash-table-count ht))
+  (print (gethash i ht)))
+
+
+;; Function MAKE-HASH-TABLE {{{
+;;
+;; Syntax:
+;; make-hash-table &key test size rehash-size rehash-threshold => hash-table
+;; Arguments and Values:
+;; test---a designator for one of the functions eq, eql, equal, or equalp. The default is eql.
+;; size---a non-negative integer. The default is implementation-dependent.
+;; rehash-size---a real of type (or (integer 1 *) (float (1.0) *)). The default is implementation-dependent.
+;; rehash-threshold---a real of type (real 0 1). The default is implementation-dependent.
+;; hash-table---a hash table.
+;; 
+;; Description:
+;; Creates and returns a new hash table.
+;; test determines how keys are compared. An object is said to be present in the hash-table if that object is the same under the test as the key for some entry in the hash-table.
+;; size is a hint to the implementation about how much initial space to allocate in the hash-table. This information, taken together with the rehash-threshold, controls the approximate number of entries which it should be possible to insert before the table has to grow. The actual size might be rounded up from size to the next `good' size; for example, some implementations might round to the next prime number.
+;; rehash-size specifies a minimum amount to increase the size of the hash-table when it becomes full enough to require rehashing; see rehash-theshold below. If rehash-size is an integer, the expected growth rate for the table is additive and the integer is the number of entries to add; if it is a float, the expected growth rate for the table is multiplicative and the float is the ratio of the new size to the old size. As with size, the actual size of the increase might be rounded up.
+;; rehash-threshold specifies how full the hash-table can get before it must grow. It specifies the maximum desired hash-table occupancy level.
+;; The values of rehash-size and rehash-threshold do not constrain the implementation to use any particular method for computing when and by how much the size of hash-table should be enlarged. Such decisions are implementation-dependent, and these values only hints from the programmer to the implementation, and the implementation is permitted to ignore them.
+;; 
+;; Examples:
+;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 46142754>
+;;  (setf (gethash "one" table) 1) =>  1
+;;  (gethash "one" table) =>  NIL, false
+;;  (setq table (make-hash-table :test 'equal)) =>  #<HASH-TABLE EQUAL 0/139 46145547>
+;;  (setf (gethash "one" table) 1) =>  1
+;;  (gethash "one" table) =>  1, T
+;;  (make-hash-table :rehash-size 1.5 :rehash-threshold 0.7) 
+;; =>  #<HASH-TABLE EQL 0/120 46156620>
+;; }}}
+;; Function HASH-TABLE-COUNT {{{
+;; 
+;; Syntax:
+;; hash-table-count hash-table => count
+;; Arguments and Values:
+;; hash-table---a hash table.
+;; count---a non-negative integer.
+;; 
+;; Description:
+;; Returns the number of entries in the hash-table. If hash-table has just been created or newly cleared (see clrhash) the entry count is 0.
+;; 
+;; Examples:
+;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32115135>
+;;  (hash-table-count table) =>  0
+;;  (setf (gethash 57 table) "fifty-seven") =>  "fifty-seven"
+;;  (hash-table-count table) =>  1
+;;  (dotimes (i 100) (setf (gethash i table) i)) =>  NIL
+;;  (hash-table-count table) =>  100
+;; Side Effects: None.
+;; 
+;; Notes:
+;; 
+;; The following relationships are functionally correct, although in practice using hash-table-count is probably much faster:
+;; 
+;;  (hash-table-count table) == 
+;;  (loop for value being the hash-values of table count t) == 
+;;  (let ((total 0))
+;;    (maphash #'(lambda (key value)
+;;                 (declare (ignore key value))
+;;                 (incf total))
+;;             table)
+;;    total)
+;; }}}
+;; Function HASH-TABLE-SIZE {{{
+;;
+;; Syntax:
+;; hash-table-size hash-table => size
+;; 
+;; Arguments and Values:
+;; hash-table---a hash table.
+;; size---a non-negative integer.
+;; 
+;; Description:
+;; Returns the current size of hash-table,
+;; which is suitable for use in a call to make-hash-table in order to produce a hash table with state corresponding to the current state of the hash-table.
+;; 
+;; 
+;; Exceptional Situations:
+;; Should signal an error of type type-error if hash-table is not a hash table.
+;; 
+;; 
+;; }}}
+;; Function CLRHASH {{{
+;; 
+;; Syntax:
+;; clrhash hash-table => hash-table
+;; 
+;; Arguments and Values:
+;; hash-table---a hash table.
+;; 
+;; Description:
+;; Removes all entries from hash-table, and then returns that empty hash table.
+;; 
+;; Examples:
+;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32004073>
+;;  (dotimes (i 100) (setf (gethash i table) (format nil "~R" i))) =>  NIL
+;;  (hash-table-count table) =>  100
+;;  (gethash 57 table) =>  "fifty-seven", true
+;;  (clrhash table) =>  #<HASH-TABLE EQL 0/120 32004073>
+;;  (hash-table-count table) =>  0
+;;  (gethash 57 table) =>  NIL, false
+;;
+;; }}}
+;; Accessor GETHASH {{{
+;; 
+;; Syntax:
+;; gethash key hash-table &optional default => value, present-p
+;; (setf (gethash key hash-table &optional default) new-value)
+;; 
+;; Arguments and Values:
+;; key---an object.
+;; hash-table---a hash table.
+;; default---an object. The default is nil.
+;; value---an object.
+;; present-p---a generalized boolean.
+;; 
+;; Description:
+;; Value is the object in hash-table whose key is the same as key under the hash-table's equivalence test. If there is no such entry, value is the default.
+;; Present-p is true if an entry is found; otherwise, it is false.
+;; setf may be used with gethash to modify the value associated with a given key, or to add a new entry. When a gethash form is used as a setf place, any default which is supplied is evaluated according to normal left-to-right evaluation rules, but its value is ignored.
+;; 
+;; Examples:
+;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32206334>
+;;  (gethash 1 table) =>  NIL, false
+;;  (gethash 1 table 2) =>  2, false
+;;  (setf (gethash 1 table) "one") =>  "one"
+;;  (setf (gethash 2 table "two") "two") =>  "two"
+;;  (gethash 1 table) =>  "one", true
+;;  (gethash 2 table) =>  "two", true
+;;  (gethash nil table) =>  NIL, false
+;;  (setf (gethash nil table) nil) =>  NIL 
+;;  (gethash nil table) =>  NIL, true
+;;  (defvar *counters* (make-hash-table)) =>  *COUNTERS*
+;;  (gethash 'foo *counters*) =>  NIL, false
+;;  (gethash 'foo *counters* 0) =>  0, false
+;;  (defmacro how-many (obj) `(values (gethash ,obj *counters* 0))) =>  HOW-MANY
+;;  (defun count-it (obj) (incf (how-many obj))) =>  COUNT-IT
+;;  (dolist (x '(bar foo foo bar bar baz)) (count-it x))
+;;  (how-many 'foo) =>  2
+;;  (how-many 'bar) =>  3
+;;  (how-many 'quux) =>  0
+;; 
+;; }}}
+;; Function REMHASH {{{
+;;
+;; Syntax:
+;; remhash key hash-table => generalized-boolean
+;;
+;; Arguments and Values:
+;; key---an object.
+;; hash-table---a hash table.
+;; generalized-boolean---a generalized boolean.
+;;
+;; Description:
+;; Removes the entry for key in hash-table, if any. Returns true if there was such an entry, or false otherwise.
+;;
+;; Examples:
+;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32115666>
+;;  (setf (gethash 100 table) "C") =>  "C"
+;;  (gethash 100 table) =>  "C", true
+;;  (remhash 100 table) =>  true
+;;  (gethash 100 table) =>  NIL, false
+;;  (remhash 100 table) =>  false
+;;
+;; }}}
+;; Function MAPHASH {{{
+;; 
+;; Syntax:
+;; maphash function hash-table => nil
+;; 
+;; Arguments and Values:
+;; function---a designator for a function of two arguments, the key and the value.
+;; hash-table---a hash table.
+;; 
+;; Description:
+;; Iterates over all entries in the hash-table. For each entry, the function is called with two arguments--the key and the value of that entry.
+;; The consequences are unspecified if any attempt is made to add or remove an entry from the hash-table while a maphash is in progress, with two exceptions: the function can use can use setf of gethash to change the value part of the entry currently being processed, or it can use remhash to remove that entry.
+;; 
+;; Examples:
+;;  (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32304110>
+;;  (dotimes (i 10) (setf (gethash i table) i)) =>  NIL
+;;  (let ((sum-of-squares 0))
+;;     (maphash #'(lambda (key val) 
+;;                  (let ((square (* val val)))
+;;                    (incf sum-of-squares square)
+;;                    (setf (gethash key table) square)))
+;;              table)
+;;     sum-of-squares) =>  285
+;;  (hash-table-count table) =>  10
+;;  (maphash #'(lambda (key val)
+;;                (when (oddp val) (remhash key table)))
+;;            table) =>  NIL
+;;  (hash-table-count table) =>  5
+;;  (maphash #'(lambda (k v) (print (list k v))) table)
+;; (0 0) 
+;; (8 64) 
+;; (2 4) 
+;; (6 36) 
+;; (4 16) 
+;; =>  NIL
+;; 
+;; }}}
diff --git a/doc/list.lisp b/doc/list.lisp
index 9640b82..6a7eae9 100644
--- a/doc/list.lisp
+++ b/doc/list.lisp
@@ -1,166 +1,165 @@
-;; See Also:
-;; sequence.lisp
-;; set.lisp
-
-;; Function push, pop
-(defparameter *stack* nil)
-
-(push 'a *stack*)
-;; <=> (setf *stack* (cons ('a *stack*)))
-
-(pop *stack*)
-;; => A
-
-
-;; Function assoc
-(defparameter *alist* '((1 . a) (2 . b) (3 . c)))
-
-(assoc 1 *alist*)
-;; => (1 . A) 
-(assoc 2 *alist*)
-;; => (2 . B) 
-(assoc 3 *alist*)
-;; => (3 . C) 
-
-;; Function SUBLIS, NSUBLIS {{{
-;; 
-;; Syntax:
-;; sublis alist tree &key key test test-not => new-tree
-;; nsublis alist tree &key key test test-not => new-tree
-;; 
-;; Arguments and Values:
-;; alist---an association list. 
-;; tree---a tree. 
-;; test---a designator for a function of two arguments that returns a generalized boolean. 
-;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
-;; key---a designator for a function of one argument, or nil. 
-;; new-tree---a tree. 
-;; 
-;; Description:
-;; sublis makes substitutions for objects in tree (a structure of conses). nsublis is like sublis but destructively modifies the relevant parts of the tree. 
-;; sublis looks at all subtrees and leaves of tree; if a subtree or leaf appears as a key in alist (that is, the key and the subtree or leaf satisfy the test), it is replaced by the object with which that key is associated. This operation is non-destructive. In effect, sublis can perform several subst operations simultaneously. 
-;; If sublis succeeds, a new copy of tree is returned in which each occurrence of such a subtree or leaf is replaced by the object with which it is associated. If no changes are made, the original tree is returned. The original tree is left unchanged, but the result tree may share cells with it. 
-;; nsublis is permitted to modify tree but otherwise returns the same values as sublis. 
-;; 
-;; Examples:
-;;  (sublis '((x . 100) (z . zprime))
-;;          '(plus x (minus g z x p) 4 . x))
-;; =>  (PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)
-;;  (sublis '(((+ x y) . (- x y)) ((- x y) . (+ x y)))
-;;          '(* (/ (+ x y) (+ x p)) (- x y))
-;;          :test #'equal)
-;; =>  (* (/ (- X Y) (+ X P)) (+ X Y))
-;;  (setq tree1 '(1 (1 2) ((1 2 3)) (((1 2 3 4)))))
-;; =>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))
-;;  (sublis '((3 . "three")) tree1) 
-;; =>  (1 (1 2) ((1 2 "three")) (((1 2 "three" 4))))
-;;  (sublis '((t . "string"))
-;;           (sublis '((1 . "") (4 . 44)) tree1)
-;;           :key #'stringp)
-;; =>  ("string" ("string" 2) (("string" 2 3)) ((("string" 2 3 44))))
-;;  tree1 =>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))
-;;  (setq tree2 '("one" ("one" "two") (("one" "Two" "three"))))
-;; =>  ("one" ("one" "two") (("one" "Two" "three"))) 
-;;  (sublis '(("two" . 2)) tree2) 
-;; =>  ("one" ("one" "two") (("one" "Two" "three"))) 
-;;  tree2 =>  ("one" ("one" "two") (("one" "Two" "three"))) 
-;;  (sublis '(("two" . 2)) tree2 :test 'equal) 
-;; =>  ("one" ("one" 2) (("one" "Two" "three"))) 
-;;  (nsublis '((t . 'temp))
-;;            tree1
-;;            :key #'(lambda (x) (or (atom x) (< (list-length x) 3))))
-;; =>  ((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP) 
-;; 
-;; Side Effects:
-;; nsublis modifies tree. 
-;; 
-;; See Also:
-;; subst, Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
-;; 
-;; Notes:
-;; The :test-not parameter is deprecated. 
-;; Because the side-effecting variants (e.g., nsublis) potentially change the path that is being traversed, their effects in the presence of shared or circular structure structure may vary in surprising ways when compared to their non-side-effecting alternatives. To see this, consider the following side-effect behavior, which might be exhibited by some implementations: 
-;;  (defun test-it (fn)
-;;    (let* ((shared-piece (list 'a 'b))
-;;           (data (list shared-piece shared-piece)))
-;;      (funcall fn '((a . b) (b . a)) data)))
-;;  (test-it #'sublis) =>  ((B A) (B A))
-;;  (test-it #'nsublis) =>  ((A B) (A B))
-;;
-;; }}}
-;; Function SUBST, SUBST-IF, SUBST-IF-NOT, NSUBST, NSUBST-IF, NSUBST-IF-NOT {{{
-;; 
-;; Syntax:
-;; subst new old tree &key key test test-not => new-tree
-;; subst-if new predicate tree &key key => new-tree
-;; subst-if-not new predicate tree &key key => new-tree
-;; nsubst new old tree &key key test test-not => new-tree
-;; nsubst-if new predicate tree &key key => new-tree
-;; nsubst-if-not new predicate tree &key key => new-tree
-;; 
-;; 
-;; Arguments and Values:
-;; new---an object. 
-;; old---an object. 
-;; predicate---a symbol that names a function, or a function of one argument that returns a generalized boolean value. 
-;; tree---a tree. 
-;; test---a designator for a function of two arguments that returns a generalized boolean. 
-;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
-;; key---a designator for a function of one argument, or nil. 
-;; new-tree---a tree. 
-;; 
-;; Description:
-;; subst, subst-if, and subst-if-not perform substitution operations on tree. Each function searches tree for occurrences of a particular old item of an element or subexpression that satisfies the test. 
-;; nsubst, nsubst-if, and nsubst-if-not are like subst, subst-if, and subst-if-not respectively, except that the original tree is modified. 
-;; subst makes a copy of tree, substituting new for every subtree or leaf of tree (whether the subtree or leaf is a car or a cdr of its parent) such that old and the subtree or leaf satisfy the test. 
-;; nsubst is a destructive version of subst. The list structure of tree is altered by destructively replacing with new each leaf of the tree such that old and the leaf satisfy the test. 
-;; For subst, subst-if, and subst-if-not, if the functions succeed, a new copy of the tree is returned in which each occurrence of such an element is replaced by the new element or subexpression. If no changes are made, the original tree may be returned. The original tree is left unchanged, but the result tree may share storage with it. 
-;; For nsubst, nsubst-if, and nsubst-if-not the original tree is modified and returned as the function result, but the result may not be eq to tree. 
-;; 
-;; Examples:
-;;  (setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))
-;;  (subst "two" 2 tree1) =>  (1 (1 "two") (1 "two" 3) (1 "two" 3 4))
-;;  (subst "five" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))
-;;  (eq tree1 (subst "five" 5 tree1)) =>  implementation-dependent
-;;  (subst 'tempest 'hurricane
-;;         '(shakespeare wrote (the hurricane)))
-;; =>  (SHAKESPEARE WROTE (THE TEMPEST))
-;;  (subst 'foo 'nil '(shakespeare wrote (twelfth night)))
-;; =>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)
-;;  (subst '(a . cons) '(old . pair)
-;;         '((old . spice) ((old . shoes) old . pair) (old . pair))
-;;         :test #'equal)
-;; =>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))
-;; 
-;;  (subst-if 5 #'listp tree1) =>  5
-;;  (subst-if-not '(x) #'consp tree1) 
-;; =>  (1 X)
-;; 
-;;  tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))
-;;  (nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) 
-;; =>  (1 (1 2) X X)
-;;  tree1 =>  (1 (1 2) X X)
-;; 
-;; Side Effects:
-;; nsubst, nsubst-if, and nsubst-if-not might alter the tree structure of tree. 
-;; 
-;; See Also:
-;; substitute, nsubstitute, Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
-;; 
-;; Notes:
-;; The :test-not parameter is deprecated. 
-;; The functions subst-if-not and nsubst-if-not are deprecated. 
-;; One possible definition of subst: 
-;;  (defun subst (old new tree &rest x &key test test-not key)
-;;    (cond ((satisfies-the-test old tree :test test
-;;                               :test-not test-not :key key)
-;;           new)
-;;          ((atom tree) tree)
-;;          (t (let ((a (apply #'subst old new (car tree) x))
-;;                   (d (apply #'subst old new (cdr tree) x)))
-;;               (if (and (eql a (car tree))
-;;                        (eql d (cdr tree)))
-;;                   tree
-;;                   (cons a d))))))
-;; 
-;; }}}
+;; See Also:
+;; sequence.lisp
+;; set.lisp
+
+;; Function push, pop
+(defparameter *stack* nil)
+
+(push 'a *stack*)
+;; <=> (setf *stack* (cons ('a *stack*)))
+
+(pop *stack*)
+;; => A
+
+;; Function assoc
+(defparameter *alist* '((1 . a) (2 . b) (3 . c)))
+
+(assoc 1 *alist*)
+;; => (1 . A) 
+(assoc 2 *alist*)
+;; => (2 . B) 
+(assoc 3 *alist*)
+;; => (3 . C) 
+
+;; Function SUBLIS, NSUBLIS {{{
+;; 
+;; Syntax:
+;; sublis alist tree &key key test test-not => new-tree
+;; nsublis alist tree &key key test test-not => new-tree
+;; 
+;; Arguments and Values:
+;; alist---an association list. 
+;; tree---a tree. 
+;; test---a designator for a function of two arguments that returns a generalized boolean. 
+;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
+;; key---a designator for a function of one argument, or nil. 
+;; new-tree---a tree. 
+;; 
+;; Description:
+;; sublis makes substitutions for objects in tree (a structure of conses). nsublis is like sublis but destructively modifies the relevant parts of the tree. 
+;; sublis looks at all subtrees and leaves of tree; if a subtree or leaf appears as a key in alist (that is, the key and the subtree or leaf satisfy the test), it is replaced by the object with which that key is associated. This operation is non-destructive. In effect, sublis can perform several subst operations simultaneously. 
+;; If sublis succeeds, a new copy of tree is returned in which each occurrence of such a subtree or leaf is replaced by the object with which it is associated. If no changes are made, the original tree is returned. The original tree is left unchanged, but the result tree may share cells with it. 
+;; nsublis is permitted to modify tree but otherwise returns the same values as sublis. 
+;; 
+;; Examples:
+;;  (sublis '((x . 100) (z . zprime))
+;;          '(plus x (minus g z x p) 4 . x))
+;; =>  (PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)
+;;  (sublis '(((+ x y) . (- x y)) ((- x y) . (+ x y)))
+;;          '(* (/ (+ x y) (+ x p)) (- x y))
+;;          :test #'equal)
+;; =>  (* (/ (- X Y) (+ X P)) (+ X Y))
+;;  (setq tree1 '(1 (1 2) ((1 2 3)) (((1 2 3 4)))))
+;; =>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))
+;;  (sublis '((3 . "three")) tree1) 
+;; =>  (1 (1 2) ((1 2 "three")) (((1 2 "three" 4))))
+;;  (sublis '((t . "string"))
+;;           (sublis '((1 . "") (4 . 44)) tree1)
+;;           :key #'stringp)
+;; =>  ("string" ("string" 2) (("string" 2 3)) ((("string" 2 3 44))))
+;;  tree1 =>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))
+;;  (setq tree2 '("one" ("one" "two") (("one" "Two" "three"))))
+;; =>  ("one" ("one" "two") (("one" "Two" "three"))) 
+;;  (sublis '(("two" . 2)) tree2) 
+;; =>  ("one" ("one" "two") (("one" "Two" "three"))) 
+;;  tree2 =>  ("one" ("one" "two") (("one" "Two" "three"))) 
+;;  (sublis '(("two" . 2)) tree2 :test 'equal) 
+;; =>  ("one" ("one" 2) (("one" "Two" "three"))) 
+;;  (nsublis '((t . 'temp))
+;;            tree1
+;;            :key #'(lambda (x) (or (atom x) (< (list-length x) 3))))
+;; =>  ((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP) 
+;; 
+;; Side Effects:
+;; nsublis modifies tree. 
+;; 
+;; See Also:
+;; subst, Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
+;; 
+;; Notes:
+;; The :test-not parameter is deprecated. 
+;; Because the side-effecting variants (e.g., nsublis) potentially change the path that is being traversed, their effects in the presence of shared or circular structure structure may vary in surprising ways when compared to their non-side-effecting alternatives. To see this, consider the following side-effect behavior, which might be exhibited by some implementations: 
+;;  (defun test-it (fn)
+;;    (let* ((shared-piece (list 'a 'b))
+;;           (data (list shared-piece shared-piece)))
+;;      (funcall fn '((a . b) (b . a)) data)))
+;;  (test-it #'sublis) =>  ((B A) (B A))
+;;  (test-it #'nsublis) =>  ((A B) (A B))
+;;
+;; }}}
+;; Function SUBST, SUBST-IF, SUBST-IF-NOT, NSUBST, NSUBST-IF, NSUBST-IF-NOT {{{
+;; 
+;; Syntax:
+;; subst new old tree &key key test test-not => new-tree
+;; subst-if new predicate tree &key key => new-tree
+;; subst-if-not new predicate tree &key key => new-tree
+;; nsubst new old tree &key key test test-not => new-tree
+;; nsubst-if new predicate tree &key key => new-tree
+;; nsubst-if-not new predicate tree &key key => new-tree
+;; 
+;; 
+;; Arguments and Values:
+;; new---an object. 
+;; old---an object. 
+;; predicate---a symbol that names a function, or a function of one argument that returns a generalized boolean value. 
+;; tree---a tree. 
+;; test---a designator for a function of two arguments that returns a generalized boolean. 
+;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
+;; key---a designator for a function of one argument, or nil. 
+;; new-tree---a tree. 
+;; 
+;; Description:
+;; subst, subst-if, and subst-if-not perform substitution operations on tree. Each function searches tree for occurrences of a particular old item of an element or subexpression that satisfies the test. 
+;; nsubst, nsubst-if, and nsubst-if-not are like subst, subst-if, and subst-if-not respectively, except that the original tree is modified. 
+;; subst makes a copy of tree, substituting new for every subtree or leaf of tree (whether the subtree or leaf is a car or a cdr of its parent) such that old and the subtree or leaf satisfy the test. 
+;; nsubst is a destructive version of subst. The list structure of tree is altered by destructively replacing with new each leaf of the tree such that old and the leaf satisfy the test. 
+;; For subst, subst-if, and subst-if-not, if the functions succeed, a new copy of the tree is returned in which each occurrence of such an element is replaced by the new element or subexpression. If no changes are made, the original tree may be returned. The original tree is left unchanged, but the result tree may share storage with it. 
+;; For nsubst, nsubst-if, and nsubst-if-not the original tree is modified and returned as the function result, but the result may not be eq to tree. 
+;; 
+;; Examples:
+;;  (setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))
+;;  (subst "two" 2 tree1) =>  (1 (1 "two") (1 "two" 3) (1 "two" 3 4))
+;;  (subst "five" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))
+;;  (eq tree1 (subst "five" 5 tree1)) =>  implementation-dependent
+;;  (subst 'tempest 'hurricane
+;;         '(shakespeare wrote (the hurricane)))
+;; =>  (SHAKESPEARE WROTE (THE TEMPEST))
+;;  (subst 'foo 'nil '(shakespeare wrote (twelfth night)))
+;; =>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)
+;;  (subst '(a . cons) '(old . pair)
+;;         '((old . spice) ((old . shoes) old . pair) (old . pair))
+;;         :test #'equal)
+;; =>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))
+;; 
+;;  (subst-if 5 #'listp tree1) =>  5
+;;  (subst-if-not '(x) #'consp tree1) 
+;; =>  (1 X)
+;; 
+;;  tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))
+;;  (nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) 
+;; =>  (1 (1 2) X X)
+;;  tree1 =>  (1 (1 2) X X)
+;; 
+;; Side Effects:
+;; nsubst, nsubst-if, and nsubst-if-not might alter the tree structure of tree. 
+;; 
+;; See Also:
+;; substitute, nsubstitute, Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
+;; 
+;; Notes:
+;; The :test-not parameter is deprecated. 
+;; The functions subst-if-not and nsubst-if-not are deprecated. 
+;; One possible definition of subst: 
+;;  (defun subst (old new tree &rest x &key test test-not key)
+;;    (cond ((satisfies-the-test old tree :test test
+;;                               :test-not test-not :key key)
+;;           new)
+;;          ((atom tree) tree)
+;;          (t (let ((a (apply #'subst old new (car tree) x))
+;;                   (d (apply #'subst old new (cdr tree) x)))
+;;               (if (and (eql a (car tree))
+;;                        (eql d (cdr tree)))
+;;                   tree
+;;                   (cons a d))))))
+;; 
+;; }}}
diff --git a/doc/loop.lisp b/doc/loop.lisp
index 3c73d4b..9b62fdc 100644
--- a/doc/loop.lisp
+++ b/doc/loop.lisp
@@ -1,4 +1,3 @@
-
 (loop for x in '(1 3 5)
       for y in '(2 4 6 8 10)
       collect (cons x y))
@@ -18,4 +17,3 @@
 ;; => (((-1 -1) (-1 0) (-1 1))
 ;;     (( 0 -1)        ( 0 1))
 ;;     (( 1 -1) ( 1 0) ( 1 1))) 
-
diff --git a/doc/math.lisp b/doc/math.lisp
deleted file mode 100644
index 094d3cd..0000000
--- a/doc/math.lisp
+++ /dev/null
@@ -1,105 +0,0 @@
-
-;; Function random
-;; {{{
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-(print (random 100))
-;; }}}
diff --git a/doc/onlisp b/doc/onlisp
index 9e920d7..5dd59b8 100644
--- a/doc/onlisp
+++ b/doc/onlisp
@@ -17651,5 +17651,3 @@ see also: quote
 240, 252, 328
 ‘ see backquote
 | 58
-
-
diff --git a/doc/pathname.lisp b/doc/pathname.lisp
index 9b184fb..cd15c78 100644
--- a/doc/pathname.lisp
+++ b/doc/pathname.lisp
@@ -1,25 +1,24 @@
-(load "../lib/stdlib")
-
-;; pathname からファイル名を取得
-(file-namestring #P"/tmp/hoge.tgz")
-;; => "hoge.tgz"
-
-;; pathname から拡張子を取得
-(pathname-type #P"/tmp/hoge.tgz")
-;; => "tgz"
-
-;; pathname からファイル名(拡張子無し)を取得
-(pathname-name #P"/tmp/hoge.tgz")
-;; => "hoge"
-
-;; pathname からディレクトリを取得
-(pathname-directory #P"/tmp/hoge.tgz")
-;; => (:ABSOLUTE "tmp")
-
-(pathname-directory #P"tmp/hoge.tgz")
-;; => (:RELATIVE "tmp")
-
-;; pathname からドライブレターを取得
-(pathname-device #P"D:/tmp/hoge.tgz")
-;; => "D"
-
+(load "../lib/stdlib")
+
+;; pathname からファイル名を取得
+(file-namestring #P"/tmp/hoge.tgz")
+;; => "hoge.tgz"
+
+;; pathname から拡張子を取得
+(pathname-type #P"/tmp/hoge.tgz")
+;; => "tgz"
+
+;; pathname からファイル名(拡張子無し)を取得
+(pathname-name #P"/tmp/hoge.tgz")
+;; => "hoge"
+
+;; pathname からディレクトリを取得
+(pathname-directory #P"/tmp/hoge.tgz")
+;; => (:ABSOLUTE "tmp")
+
+(pathname-directory #P"tmp/hoge.tgz")
+;; => (:RELATIVE "tmp")
+
+;; pathname からドライブレターを取得
+(pathname-device #P"D:/tmp/hoge.tgz")
+;; => "D"
diff --git a/doc/quicklisp.lisp b/doc/quicklisp.lisp
index 42ec7dc..a5e5fa9 100644
--- a/doc/quicklisp.lisp
+++ b/doc/quicklisp.lisp
@@ -1,4 +1,3 @@
-
 (load "quicklisp.lisp")
 (quicklisp-quickstart:install)
 (ql:add-to-init-file)
diff --git a/doc/sequence.lisp b/doc/sequence.lisp
index 331358c..69f6f07 100644
--- a/doc/sequence.lisp
+++ b/doc/sequence.lisp
@@ -1,6 +1,5 @@
 (load "../lib/stdlib")
 
-
 ;; before, after
 (before #\s "asdfasdf")
 ;; => "a" 
diff --git a/doc/set.lisp b/doc/set.lisp
index cababb1..7fd52bc 100644
--- a/doc/set.lisp
+++ b/doc/set.lisp
@@ -1,240 +1,236 @@
-(load "../lib/stdlib")
-
-(member 'b '(a b c))
-;; => (B C) 
-(member '(a) '((a) (z)))
-;; => NIL 
-(member '(a) '((a) (z)) :test #'equal)
-;; => ((A) (Z)) 
-(member 'a '((a b) (c d)) :key #'car)
-;; => ((A B) (C D)) 
-
-(member-if #'oddp '(2 3 4 5 6))
-;; => (3 4 5 6) 
-(member-if #'evenp '(2 3 4 5 6))
-;; => (2 3 4 5 6) 
-
-(adjoin 'b '(a b c))
-;; => (A B C) 
-(adjoin 'z '(a b c))
-;; => (Z A B C) 
-
-
-(union '(a b c) '(c b s))
-;; => (A C B S) 
-(intersection '(a b c) '(b b c))
-;; => (B C) 
-(set-difference '(a b c d e) '(b e))
-;; => (A C D) 
-
-
-;; Function MEMBER, MEMBER-IF, MEMBER-IF-NOT {{{
-;; 
-;; Syntax:
-;; member item list &key key test test-not => tail
-;; member-if predicate list &key key => tail
-;; member-if-not predicate list &key key => tail
-;; 
-;; Arguments and Values:
-;; item---an object. 
-;; list---a proper list. 
-;; predicate---a designator for a function of one argument that returns a generalized boolean. 
-;; test---a designator for a function of two arguments that returns a generalized boolean. 
-;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
-;; key---a designator for a function of one argument, or nil. 
-;; tail---a list. 
-;; 
-;; Description:
-;; member, member-if, and member-if-not each search list for item or for a top-level element that satisfies the test. The argument to the predicate function is an element of list. 
-;; If some element satisfies the test, the tail of list beginning with this element is returned; otherwise nil is returned. 
-;; list is searched on the top level only. 
-;; 
-;; Examples:
-;;  (member 2 '(1 2 3)) =>  (2 3)                                 
-;;  (member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) =>  ((3 . 4))
-;;  (member 'e '(a b c d)) =>  NIL
-;;
-;;  (member-if #'listp '(a b nil c d)) =>  (NIL C D)
-;;  (member-if #'numberp '(a #\Space 5/3 foo)) =>  (5/3 FOO)
-;;  (member-if-not #'zerop 
-;;                  '(3 6 9 11 . 12)
-;;                  :key #'(lambda (x) (mod x 3))) =>  (11 . 12)
-;; 
-;; Exceptional Situations:
-;; Should be prepared to signal an error of type type-error if list is not a proper list. 
-;; 
-;; See Also:
-;; find, position, Section 3.6 (Traversal Rules and Side Effects) 
-;; 
-;; Notes:
-;; The :test-not parameter is deprecated. 
-;; The function member-if-not is deprecated. 
-;; In the following 
-;;  (member 'a '(g (a y) c a d e a f)) =>  (A D E A F)
-;; the value returned by member is identical to the portion of the list beginning with a. Thus rplaca on the result of member can be used to alter the part of the list where a was found (assuming a check has been made that member did not return nil). 
-;;
-;; }}}
-;; Function SET-DIFFERENCE, NSET-DIFFERENCE {{{
-;; 
-;; Syntax:
-;; set-difference list-1 list-2 &key key test test-not => result-list
-;; nset-difference list-1 list-2 &key key test test-not => result-list
-;; 
-;; Arguments and Values:
-;; list-1---a proper list. 
-;; list-2---a proper list. 
-;; test---a designator for a function of two arguments that returns a generalized boolean. 
-;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
-;; key---a designator for a function of one argument, or nil. 
-;; result-list---a list. 
-;; 
-;; Description:
-;; set-difference returns a list of elements of list-1 that do not appear in list-2. 
-;; nset-difference is the destructive version of set-difference. It may destroy list-1. 
-;; For all possible ordered pairs consisting of one element from list-1 and one element from list-2, the :test or :test-not function is used to determine whether they satisfy the test. The first argument to the :test or :test-not function is the part of an element of list-1 that is returned by the :key function (if supplied); the second argument is the part of an element of list-2 that is returned by the :key function (if supplied). 
-;; If :key is supplied, its argument is a list-1 or list-2 element. The :key function typically returns part of the supplied element. If :key is not supplied, the list-1 or list-2 element is used. 
-;; An element of list-1 appears in the result if and only if it does not match any element of list-2. 
-;; There is no guarantee that the order of elements in the result will reflect the ordering of the arguments in any particular way. The result list may share cells with, or be eq to, either of list-1 or list-2, if appropriate. 
-;; 
-;; Examples:
-;;  (setq lst1 (list "A" "b" "C" "d")
-;;        lst2 (list "a" "B" "C" "d")) =>  ("a" "B" "C" "d")
-;;  (set-difference lst1 lst2) =>  ("d" "C" "b" "A")
-;;  (set-difference lst1 lst2 :test 'equal) =>  ("b" "A")
-;;  (set-difference lst1 lst2 :test #'equalp) =>  NIL 
-;;  (nset-difference lst1 lst2 :test #'string=) =>  ("A" "b")
-;;  (setq lst1 '(("a" . "b") ("c" . "d") ("e" . "f")))
-;; =>  (("a" . "b") ("c" . "d") ("e" . "f")) 
-;;  (setq lst2 '(("c" . "a") ("e" . "b") ("d" . "a")))
-;; =>  (("c" . "a") ("e" . "b") ("d" . "a")) 
-;;  (nset-difference lst1 lst2 :test #'string= :key #'cdr)
-;; =>  (("c" . "d") ("e" . "f")) 
-;;  lst1 =>  (("a" . "b") ("c" . "d") ("e" . "f")) 
-;;  lst2 =>  (("c" . "a") ("e" . "b") ("d" . "a")) 
-;; 
-;; ;; Remove all flavor names that contain "c" or "w".
-;;  (set-difference '("strawberry" "chocolate" "banana"
-;;                   "lemon" "pistachio" "rhubarb")
-;;           '(#\c #\w)
-;;           :test #'(lambda (s c) (find c s)))
-;; =>  ("banana" "rhubarb" "lemon")    ;One possible ordering.
-;; 
-;; Side Effects:
-;; nset-difference may destroy list-1. 
-;; 
-;; Exceptional Situations:
-;; Should be prepared to signal an error of type type-error if list-1 and list-2 are not proper lists. 
-;; 
-;; See Also:
-;; Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
-;; 
-;; Notes:
-;; The :test-not parameter is deprecated. 
-;;
-;; }}}
-;; Function UNION, NUNION {{{
-;; 
-;; Syntax:
-;; union list-1 list-2 &key key test test-not => result-list
-;; nunion list-1 list-2 &key key test test-not => result-list
-;; 
-;; Arguments and Values:
-;; list-1---a proper list. 
-;; list-2---a proper list. 
-;; test---a designator for a function of two arguments that returns a generalized boolean. 
-;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
-;; key---a designator for a function of one argument, or nil. 
-;; result-list---a list. 
-;; 
-;; Description:
-;; union and nunion return a list that contains every element that occurs in either list-1 or list-2. 
-;; For all possible ordered pairs consisting of one element from list-1 and one element from list-2, :test or :test-not is used to determine whether they satisfy the test. The first argument to the :test or :test-not function is the part of the element of list-1 extracted by the :key function (if supplied); the second argument is the part of the element of list-2 extracted by the :key function (if supplied). 
-;; The argument to the :key function is an element of list-1 or list-2; the return value is part of the supplied element. If :key is not supplied or nil, the element of list-1 or list-2 itself is supplied to the :test or :test-not function. 
-;; For every matching pair, one of the two elements of the pair will be in the result. Any element from either list-1 or list-2 that matches no element of the other will appear in the result. 
-;; If there is a duplication between list-1 and list-2, only one of the duplicate instances will be in the result. If either list-1 or list-2 has duplicate entries within it, the redundant entries might or might not appear in the result. 
-;; The order of elements in the result do not have to reflect the ordering of list-1 or list-2 in any way. The result list may be eq to either list-1 or list-2 if appropriate. 
-;; 
-;; Examples:
-;;  (union '(a b c) '(f a d))
-;; =>  (A B C F D)
-;; OR=>  (B C F A D)
-;; OR=>  (D F A B C)
-;;  (union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)
-;; =>  ((X 5) (Y 6) (Z 2))
-;; OR=>  ((X 4) (Y 6) (Z 2))
-;; 
-;;  (setq lst1 (list 1 2 '(1 2) "a" "b")
-;;        lst2 (list 2 3 '(2 3) "B" "C"))
-;; =>  (2 3 (2 3) "B" "C")
-;;  (nunion lst1 lst2)
-;; =>  (1 (1 2) "a" "b" 2 3 (2 3) "B" "C") 
-;; OR=>  (1 2 (1 2) "a" "b" "C" "B" (2 3) 3)
-;; 
-;; Side Effects:
-;; nunion is permitted to modify any part, car or cdr, of the list structure of list-1 or list-2. 
-;; 
-;; Exceptional Situations:
-;; Should be prepared to signal an error of type type-error if list-1 and list-2 are not proper lists. 
-;; 
-;; See Also:
-;; intersection, Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
-;; 
-;; Notes:
-;; The :test-not parameter is deprecated. 
-;; Since the nunion side effect is not required, it should not be used in for-effect-only positions in portable code. 
-;; }}}
-;; Function INTERSECTION, NINTERSECTION {{{
-;; 
-;; Syntax:
-;; intersection list-1 list-2 &key key test test-not => result-list
-;; nintersection list-1 list-2 &key key test test-not => result-list
-;; 
-;; Arguments and Values:
-;; list-1---a proper list. 
-;; list-2---a proper list. 
-;; test---a designator for a function of two arguments that returns a generalized boolean. 
-;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
-;; key---a designator for a function of one argument, or nil. 
-;; result-list---a list. 
-;; 
-;; Description:
-;; intersection and nintersection return a list that contains every element that occurs in both list-1 and list-2. 
-;; nintersection is the destructive version of intersection. It performs the same operation, but may destroy list-1 using its cells to construct the result. list-2 is not destroyed. 
-;; The intersection operation is described as follows. For all possible ordered pairs consisting of one element from list-1 and one element from list-2, :test or :test-not are used to determine whether they satisfy the test. The first argument to the :test or :test-not function is an element of list-1; the second argument is an element of list-2. If :test or :test-not is not supplied, eql is used. It is an error if :test and :test-not are supplied in the same function call. 
-;; If :key is supplied (and not nil), it is used to extract the part to be tested from the list element. The argument to the :key function is an element of either list-1 or list-2; the :key function typically returns part of the supplied element. If :key is not supplied or nil, the list-1 and list-2 elements are used. 
-;; For every pair that satifies the test, exactly one of the two elements of the pair will be put in the result. No element from either list appears in the result that does not satisfy the test for an element from the other list. If one of the lists contains duplicate elements, there may be duplication in the result. 
-;; There is no guarantee that the order of elements in the result will reflect the ordering of the arguments in any particular way. The result list may share cells with, or be eq to, either list-1 or list-2 if appropriate. 
-;; 
-;; Examples:
-;;  (setq list1 (list 1 1 2 3 4 a b c "A" "B" "C" "d")
-;;        list2 (list 1 4 5 b c d "a" "B" "c" "D")) 
-;;   =>  (1 4 5 B C D "a" "B" "c" "D")
-;;  (intersection list1 list2) =>  (C B 4 1 1)
-;;  (intersection list1 list2 :test 'equal) =>  ("B" C B 4 1 1)
-;;  (intersection list1 list2 :test #'equalp) =>  ("d" "C" "B" "A" C B 4 1 1) 
-;;  (nintersection list1 list2) =>  (1 1 4 B C)
-;;  list1 =>  implementation-dependent ;e.g.,  (1 1 4 B C)
-;;  list2 =>  implementation-dependent ;e.g.,  (1 4 5 B C D "a" "B" "c" "D")
-;;  (setq list1 (copy-list '((1 . 2) (2 . 3) (3 . 4) (4 . 5))))
-;; =>  ((1 . 2) (2 . 3) (3 . 4) (4 . 5)) 
-;;  (setq list2 (copy-list '((1 . 3) (2 . 4) (3 . 6) (4 . 8))))
-;; =>  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) 
-;;  (nintersection list1 list2 :key #'cdr) =>  ((2 . 3) (3 . 4)) 
-;;  list1 =>  implementation-dependent ;e.g.,  ((1 . 2) (2 . 3) (3 . 4)) 
-;;  list2 =>  implementation-dependent ;e.g.,  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) 
-;; 
-;; Side Effects:
-;; nintersection can modify list-1, but not list-2. 
-;; 
-;; Exceptional Situations:
-;; Should be prepared to signal an error of type type-error if list-1 and list-2 are not proper lists. 
-;;
-;; See Also:
-;; union, Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
-;; 
-;; Notes:
-;; The :test-not parameter is deprecated. 
-;; Since the nintersection side effect is not required, it should not be used in for-effect-only positions in portable code. 
-;; }}}
-
-
+(load "../lib/stdlib")
+
+(member 'b '(a b c))
+;; => (B C) 
+(member '(a) '((a) (z)))
+;; => NIL 
+(member '(a) '((a) (z)) :test #'equal)
+;; => ((A) (Z)) 
+(member 'a '((a b) (c d)) :key #'car)
+;; => ((A B) (C D)) 
+
+(member-if #'oddp '(2 3 4 5 6))
+;; => (3 4 5 6) 
+(member-if #'evenp '(2 3 4 5 6))
+;; => (2 3 4 5 6) 
+
+(adjoin 'b '(a b c))
+;; => (A B C) 
+(adjoin 'z '(a b c))
+;; => (Z A B C) 
+
+(union '(a b c) '(c b s))
+;; => (A C B S) 
+(intersection '(a b c) '(b b c))
+;; => (B C) 
+(set-difference '(a b c d e) '(b e))
+;; => (A C D) 
+
+;; Function MEMBER, MEMBER-IF, MEMBER-IF-NOT {{{
+;; 
+;; Syntax:
+;; member item list &key key test test-not => tail
+;; member-if predicate list &key key => tail
+;; member-if-not predicate list &key key => tail
+;; 
+;; Arguments and Values:
+;; item---an object. 
+;; list---a proper list. 
+;; predicate---a designator for a function of one argument that returns a generalized boolean. 
+;; test---a designator for a function of two arguments that returns a generalized boolean. 
+;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
+;; key---a designator for a function of one argument, or nil. 
+;; tail---a list. 
+;; 
+;; Description:
+;; member, member-if, and member-if-not each search list for item or for a top-level element that satisfies the test. The argument to the predicate function is an element of list. 
+;; If some element satisfies the test, the tail of list beginning with this element is returned; otherwise nil is returned. 
+;; list is searched on the top level only. 
+;; 
+;; Examples:
+;;  (member 2 '(1 2 3)) =>  (2 3)                                 
+;;  (member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) =>  ((3 . 4))
+;;  (member 'e '(a b c d)) =>  NIL
+;;
+;;  (member-if #'listp '(a b nil c d)) =>  (NIL C D)
+;;  (member-if #'numberp '(a #\Space 5/3 foo)) =>  (5/3 FOO)
+;;  (member-if-not #'zerop 
+;;                  '(3 6 9 11 . 12)
+;;                  :key #'(lambda (x) (mod x 3))) =>  (11 . 12)
+;; 
+;; Exceptional Situations:
+;; Should be prepared to signal an error of type type-error if list is not a proper list. 
+;; 
+;; See Also:
+;; find, position, Section 3.6 (Traversal Rules and Side Effects) 
+;; 
+;; Notes:
+;; The :test-not parameter is deprecated. 
+;; The function member-if-not is deprecated. 
+;; In the following 
+;;  (member 'a '(g (a y) c a d e a f)) =>  (A D E A F)
+;; the value returned by member is identical to the portion of the list beginning with a. Thus rplaca on the result of member can be used to alter the part of the list where a was found (assuming a check has been made that member did not return nil). 
+;;
+;; }}}
+;; Function SET-DIFFERENCE, NSET-DIFFERENCE {{{
+;; 
+;; Syntax:
+;; set-difference list-1 list-2 &key key test test-not => result-list
+;; nset-difference list-1 list-2 &key key test test-not => result-list
+;; 
+;; Arguments and Values:
+;; list-1---a proper list. 
+;; list-2---a proper list. 
+;; test---a designator for a function of two arguments that returns a generalized boolean. 
+;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
+;; key---a designator for a function of one argument, or nil. 
+;; result-list---a list. 
+;; 
+;; Description:
+;; set-difference returns a list of elements of list-1 that do not appear in list-2. 
+;; nset-difference is the destructive version of set-difference. It may destroy list-1. 
+;; For all possible ordered pairs consisting of one element from list-1 and one element from list-2, the :test or :test-not function is used to determine whether they satisfy the test. The first argument to the :test or :test-not function is the part of an element of list-1 that is returned by the :key function (if supplied); the second argument is the part of an element of list-2 that is returned by the :key function (if supplied). 
+;; If :key is supplied, its argument is a list-1 or list-2 element. The :key function typically returns part of the supplied element. If :key is not supplied, the list-1 or list-2 element is used. 
+;; An element of list-1 appears in the result if and only if it does not match any element of list-2. 
+;; There is no guarantee that the order of elements in the result will reflect the ordering of the arguments in any particular way. The result list may share cells with, or be eq to, either of list-1 or list-2, if appropriate. 
+;; 
+;; Examples:
+;;  (setq lst1 (list "A" "b" "C" "d")
+;;        lst2 (list "a" "B" "C" "d")) =>  ("a" "B" "C" "d")
+;;  (set-difference lst1 lst2) =>  ("d" "C" "b" "A")
+;;  (set-difference lst1 lst2 :test 'equal) =>  ("b" "A")
+;;  (set-difference lst1 lst2 :test #'equalp) =>  NIL 
+;;  (nset-difference lst1 lst2 :test #'string=) =>  ("A" "b")
+;;  (setq lst1 '(("a" . "b") ("c" . "d") ("e" . "f")))
+;; =>  (("a" . "b") ("c" . "d") ("e" . "f")) 
+;;  (setq lst2 '(("c" . "a") ("e" . "b") ("d" . "a")))
+;; =>  (("c" . "a") ("e" . "b") ("d" . "a")) 
+;;  (nset-difference lst1 lst2 :test #'string= :key #'cdr)
+;; =>  (("c" . "d") ("e" . "f")) 
+;;  lst1 =>  (("a" . "b") ("c" . "d") ("e" . "f")) 
+;;  lst2 =>  (("c" . "a") ("e" . "b") ("d" . "a")) 
+;; 
+;; ;; Remove all flavor names that contain "c" or "w".
+;;  (set-difference '("strawberry" "chocolate" "banana"
+;;                   "lemon" "pistachio" "rhubarb")
+;;           '(#\c #\w)
+;;           :test #'(lambda (s c) (find c s)))
+;; =>  ("banana" "rhubarb" "lemon")    ;One possible ordering.
+;; 
+;; Side Effects:
+;; nset-difference may destroy list-1. 
+;; 
+;; Exceptional Situations:
+;; Should be prepared to signal an error of type type-error if list-1 and list-2 are not proper lists. 
+;; 
+;; See Also:
+;; Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
+;; 
+;; Notes:
+;; The :test-not parameter is deprecated. 
+;;
+;; }}}
+;; Function UNION, NUNION {{{
+;; 
+;; Syntax:
+;; union list-1 list-2 &key key test test-not => result-list
+;; nunion list-1 list-2 &key key test test-not => result-list
+;; 
+;; Arguments and Values:
+;; list-1---a proper list. 
+;; list-2---a proper list. 
+;; test---a designator for a function of two arguments that returns a generalized boolean. 
+;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
+;; key---a designator for a function of one argument, or nil. 
+;; result-list---a list. 
+;; 
+;; Description:
+;; union and nunion return a list that contains every element that occurs in either list-1 or list-2. 
+;; For all possible ordered pairs consisting of one element from list-1 and one element from list-2, :test or :test-not is used to determine whether they satisfy the test. The first argument to the :test or :test-not function is the part of the element of list-1 extracted by the :key function (if supplied); the second argument is the part of the element of list-2 extracted by the :key function (if supplied). 
+;; The argument to the :key function is an element of list-1 or list-2; the return value is part of the supplied element. If :key is not supplied or nil, the element of list-1 or list-2 itself is supplied to the :test or :test-not function. 
+;; For every matching pair, one of the two elements of the pair will be in the result. Any element from either list-1 or list-2 that matches no element of the other will appear in the result. 
+;; If there is a duplication between list-1 and list-2, only one of the duplicate instances will be in the result. If either list-1 or list-2 has duplicate entries within it, the redundant entries might or might not appear in the result. 
+;; The order of elements in the result do not have to reflect the ordering of list-1 or list-2 in any way. The result list may be eq to either list-1 or list-2 if appropriate. 
+;; 
+;; Examples:
+;;  (union '(a b c) '(f a d))
+;; =>  (A B C F D)
+;; OR=>  (B C F A D)
+;; OR=>  (D F A B C)
+;;  (union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)
+;; =>  ((X 5) (Y 6) (Z 2))
+;; OR=>  ((X 4) (Y 6) (Z 2))
+;; 
+;;  (setq lst1 (list 1 2 '(1 2) "a" "b")
+;;        lst2 (list 2 3 '(2 3) "B" "C"))
+;; =>  (2 3 (2 3) "B" "C")
+;;  (nunion lst1 lst2)
+;; =>  (1 (1 2) "a" "b" 2 3 (2 3) "B" "C") 
+;; OR=>  (1 2 (1 2) "a" "b" "C" "B" (2 3) 3)
+;; 
+;; Side Effects:
+;; nunion is permitted to modify any part, car or cdr, of the list structure of list-1 or list-2. 
+;; 
+;; Exceptional Situations:
+;; Should be prepared to signal an error of type type-error if list-1 and list-2 are not proper lists. 
+;; 
+;; See Also:
+;; intersection, Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
+;; 
+;; Notes:
+;; The :test-not parameter is deprecated. 
+;; Since the nunion side effect is not required, it should not be used in for-effect-only positions in portable code. 
+;; }}}
+;; Function INTERSECTION, NINTERSECTION {{{
+;; 
+;; Syntax:
+;; intersection list-1 list-2 &key key test test-not => result-list
+;; nintersection list-1 list-2 &key key test test-not => result-list
+;; 
+;; Arguments and Values:
+;; list-1---a proper list. 
+;; list-2---a proper list. 
+;; test---a designator for a function of two arguments that returns a generalized boolean. 
+;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
+;; key---a designator for a function of one argument, or nil. 
+;; result-list---a list. 
+;; 
+;; Description:
+;; intersection and nintersection return a list that contains every element that occurs in both list-1 and list-2. 
+;; nintersection is the destructive version of intersection. It performs the same operation, but may destroy list-1 using its cells to construct the result. list-2 is not destroyed. 
+;; The intersection operation is described as follows. For all possible ordered pairs consisting of one element from list-1 and one element from list-2, :test or :test-not are used to determine whether they satisfy the test. The first argument to the :test or :test-not function is an element of list-1; the second argument is an element of list-2. If :test or :test-not is not supplied, eql is used. It is an error if :test and :test-not are supplied in the same function call. 
+;; If :key is supplied (and not nil), it is used to extract the part to be tested from the list element. The argument to the :key function is an element of either list-1 or list-2; the :key function typically returns part of the supplied element. If :key is not supplied or nil, the list-1 and list-2 elements are used. 
+;; For every pair that satifies the test, exactly one of the two elements of the pair will be put in the result. No element from either list appears in the result that does not satisfy the test for an element from the other list. If one of the lists contains duplicate elements, there may be duplication in the result. 
+;; There is no guarantee that the order of elements in the result will reflect the ordering of the arguments in any particular way. The result list may share cells with, or be eq to, either list-1 or list-2 if appropriate. 
+;; 
+;; Examples:
+;;  (setq list1 (list 1 1 2 3 4 a b c "A" "B" "C" "d")
+;;        list2 (list 1 4 5 b c d "a" "B" "c" "D")) 
+;;   =>  (1 4 5 B C D "a" "B" "c" "D")
+;;  (intersection list1 list2) =>  (C B 4 1 1)
+;;  (intersection list1 list2 :test 'equal) =>  ("B" C B 4 1 1)
+;;  (intersection list1 list2 :test #'equalp) =>  ("d" "C" "B" "A" C B 4 1 1) 
+;;  (nintersection list1 list2) =>  (1 1 4 B C)
+;;  list1 =>  implementation-dependent ;e.g.,  (1 1 4 B C)
+;;  list2 =>  implementation-dependent ;e.g.,  (1 4 5 B C D "a" "B" "c" "D")
+;;  (setq list1 (copy-list '((1 . 2) (2 . 3) (3 . 4) (4 . 5))))
+;; =>  ((1 . 2) (2 . 3) (3 . 4) (4 . 5)) 
+;;  (setq list2 (copy-list '((1 . 3) (2 . 4) (3 . 6) (4 . 8))))
+;; =>  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) 
+;;  (nintersection list1 list2 :key #'cdr) =>  ((2 . 3) (3 . 4)) 
+;;  list1 =>  implementation-dependent ;e.g.,  ((1 . 2) (2 . 3) (3 . 4)) 
+;;  list2 =>  implementation-dependent ;e.g.,  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) 
+;; 
+;; Side Effects:
+;; nintersection can modify list-1, but not list-2. 
+;; 
+;; Exceptional Situations:
+;; Should be prepared to signal an error of type type-error if list-1 and list-2 are not proper lists. 
+;;
+;; See Also:
+;; union, Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects) 
+;; 
+;; Notes:
+;; The :test-not parameter is deprecated. 
+;; Since the nintersection side effect is not required, it should not be used in for-effect-only positions in portable code. 
+;; }}}
diff --git a/doc/string.lisp b/doc/string.lisp
index 883a04b..b645fc2 100644
--- a/doc/string.lisp
+++ b/doc/string.lisp
@@ -1,192 +1,192 @@
-(load "../lib/stdlib")
-
-;; See Also: sequence.lisp
-
-;; mkstr
-(mkstr "abc" "def" #\h #\i "klmb")
-;; => "abcdefhiklmb" 
-
-;; position
-(position #\3 "12345")
-;; => 2
-
-;; before, after
-(before #\3 "12345")
-;; => "12"
-(after #\3 "12345")
-;; => "45"
-
-;; string->list
-(string->list #\, "abcd,e,f,,g,hi,j,klmnop,qr,")
-;; => ("abcd" "e" "f" "" "g" "hi" "j" "klmnop" "qr" "") 
-
-
-;; FUNCTION STRING {{{
-;; Syntax:
-;; string x => string
-;;
-;; Arguments and Values:
-;; x---a string, a symbol, or a character.
-;; string---a string.
-;;
-;; Description:
-;; Returns a string described by x; specifically:
-;; If x is a string, it is returned.
-;; If x is a symbol, its name is returned.
-;; If x is a character, then a string containing that one character is returned.
-;; string might perform additional, implementation-defined conversions.
-;;
-;; Examples:
-;;  (string "already a string") =>  "already a string"
-;;  (string 'elm) =>  "ELM"
-;;  (string #\c) =>  "c"
-;; }}}
-;; Function MAKE-STRING {{{
-;; 
-;; Syntax:
-;; make-string size &key initial-element element-type => string
-;;
-;; Arguments and Values:
-;; size---a valid array dimension. 
-;; initial-element---a character. The default is implementation-dependent. 
-;; element-type---a type specifier. The default is character. 
-;; string---a simple string. 
-;; 
-;; Description:
-;; make-string returns a simple string of length size whose elements have been initialized to initial-element. 
-;; The element-type names the type of the elements of the string; a string is constructed of the most specialized type that can accommodate elements of the given type. 
-;; 
-;; Examples:
-;;  (make-string 10 :initial-element #\5) =>  "5555555555"
-;;  (length (make-string 10)) =>  10
-;; 
-;; }}}
-;; FUNCTION STRING=, STRING/=, STRING<, STRING>, ...{{{
-;; string= string1 string2 &key start1 end1 start2 end2 => generalized-boolean
-;; string/= string1 string2 &key start1 end1 start2 end2 => mismatch-index
-;; string< string1 string2 &key start1 end1 start2 end2 => mismatch-index
-;; string> string1 string2 &key start1 end1 start2 end2 => mismatch-index
-;; string<= string1 string2 &key start1 end1 start2 end2 => mismatch-index
-;; string>= string1 string2 &key start1 end1 start2 end2 => mismatch-index
-;; string-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean
-;; string-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index
-;; string-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index
-;; string-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index
-;; string-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index
-;; string-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index
-
-;; string1---a string designator.
-;; string2---a string designator.
-;; start1, end1---bounding index designators of string1. The defaults for start and end are 0 and nil, respectively.
-;; start2, end2---bounding index designators of string2. The defaults for start and end are 0 and nil, respectively.
-;; generalized-boolean---a generalized boolean.
-;; mismatch-index---a bounding index of string1, or nil.
-
-(string= "foo" "foo")
-;; =>  true
-(string= "foo" "Foo")
-;; =>  false
-(string= "foo" "bar")
-;; =>  false
-(string= "together" "frog" :start1 1 :end1 3 :start2 2)
-;; =>  true
-(string-equal "foo" "Foo")
-;; =>  true
-(string= "abcd" "01234abcd9012" :start2 5 :end2 9)
-;; =>  true
-(string< "aaaa" "aaab")
-;; =>  3
-(string>= "aaaaa" "aaaa")
-;; =>  4
-(string-not-greaterp "Abcde" "abcdE")
-;; =>  5
-(string-lessp "012AAAA789" "01aaab6" :start1 3 :end1 7
-              :start2 2 :end2 6)
-;; =>  6
-(string-not-equal "AAAA" "aaaA")
-;; =>  false
-
-;; }}}
-;; Function STRING-UPCASE, STRING-DOWNCASE, STRING-CAPITALIZE, NSTRING-UPCASE, NSTRING-DOWNCASE, NSTRING-CAPITALIZE {{{
-;; 
-;; Syntax:
-;; string-upcase string &key start end => cased-string
-;; string-downcase string &key start end => cased-string
-;; string-capitalize string &key start end => cased-string
-;; nstring-upcase string &key start end => string
-;; nstring-downcase string &key start end => string
-;; nstring-capitalize string &key start end => string
-;; 
-;; Arguments and Values:
-;; string---a string designator. For nstring-upcase, nstring-downcase, and nstring-capitalize, the string designator must be a string. 
-;; start, end---bounding index designators of string. The defaults for start and end are 0 and nil, respectively. 
-;; cased-string---a string. 
-;; 
-;; Description:
-;; string-upcase, string-downcase, string-capitalize, nstring-upcase, nstring-downcase, nstring-capitalize change the case of the subsequence of string bounded by start and end as follows: 
-;; string-upcase 
-;; string-upcase returns a string just like string with all lowercase characters replaced by the corresponding uppercase characters. More precisely, each character of the result string is produced by applying the function char-upcase to the corresponding character of string. 
-;; string-downcase 
-;; string-downcase is like string-upcase except that all uppercase characters are replaced by the corresponding lowercase characters (using char-downcase). 
-;; string-capitalize 
-;; string-capitalize produces a copy of string such that, for every word in the copy, the first character of the ``word,'' if it has case, is uppercase and any other characters with case in the word are lowercase. For the purposes of string-capitalize, a ``word'' is defined to be a consecutive subsequence consisting of alphanumeric characters, delimited at each end either by a non-alphanumeric character or by an end of the string. 
-;; nstring-upcase, nstring-downcase, nstring-capitalize  
-;; nstring-upcase, nstring-downcase, and nstring-capitalize are identical to string-upcase, string-downcase, and string-capitalize respectively except that they modify string. 
-;; For string-upcase, string-downcase, and string-capitalize, string is not modified. However, if no characters in string require conversion, the result may be either string or a copy of it, at the implementation's discretion. 
-;; 
-;; Examples:
-;;  (string-upcase "abcde") =>  "ABCDE"
-;;  (string-upcase "Dr. Livingston, I presume?")
-;; =>  "DR. LIVINGSTON, I PRESUME?"
-;;  (string-upcase "Dr. Livingston, I presume?" :start 6 :end 10)
-;; =>  "Dr. LiVINGston, I presume?"
-;;  (string-downcase "Dr. Livingston, I presume?")
-;; =>  "dr. livingston, i presume?"
-;; 
-;;  (string-capitalize "elm 13c arthur;fig don't") =>  "Elm 13c Arthur;Fig Don'T"
-;;  (string-capitalize " hello ") =>  " Hello "
-;;  (string-capitalize "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION")
-;; =>   "Occluded Casements Forestall Inadvertent Defenestration"
-;;  (string-capitalize 'kludgy-hash-search) =>  "Kludgy-Hash-Search"
-;;  (string-capitalize "DON'T!") =>  "Don'T!"    ;not "Don't!"
-;;  (string-capitalize "pipe 13a, foo16c") =>  "Pipe 13a, Foo16c"
-;; 
-;;  (setq str (copy-seq "0123ABCD890a")) =>  "0123ABCD890a"
-;;  (nstring-downcase str :start 5 :end 7) =>  "0123AbcD890a"
-;;  str =>  "0123AbcD890a"
-;; 
-;; Side Effects:
-;; nstring-upcase, nstring-downcase, and nstring-capitalize modify string as appropriate rather than constructing a new string. 
-;; 
-;; }}}
-;; Function SEARCH {{{
-;; 
-;; Syntax:
-;; search sequence-1 sequence-2 &key from-end test test-not key start1 start2 end1 end2
-;; => position
-;; 
-;; Arguments and Values:
-;; Sequence-1---a sequence. 
-;; Sequence-2---a sequence. 
-;; from-end---a generalized boolean. The default is false. 
-;; test---a designator for a function of two arguments that returns a generalized boolean. 
-;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
-;; key---a designator for a function of one argument, or nil. 
-;; start1, end1---bounding index designators of sequence-1. The defaults for start1 and end1 are 0 and nil, respectively. 
-;; start2, end2---bounding index designators of sequence-2. The defaults for start2 and end2 are 0 and nil, respectively. 
-;; position---a bounding index of sequence-2, or nil. 
-;; 
-;; Description:
-;; Searches sequence-2 for a subsequence that matches sequence-1. 
-;; The implementation may choose to search sequence-2 in any order; there is no guarantee on the number of times the test is made. For example, when start-end is true, the sequence might actually be searched from left to right instead of from right to left (but in either case would return the rightmost matching subsequence). If the search succeeds, search returns the offset into sequence-2 of the first element of the leftmost or rightmost matching subsequence, depending on from-end; otherwise search returns nil. 
-;; If from-end is true, the index of the leftmost element of the rightmost matching subsequence is returned. 
-;; 
-;; Examples:
-;;  (search "dog" "it's a dog's life") =>  7
-;;  (search '(0 1) '(2 4 6 1 3 5) :key #'oddp) =>  2
-;;
-;; Notes:
-;; The :test-not argument is deprecated. 
-;; 
-;; 
-;; }}}
+(load "../lib/stdlib")
+
+;; See Also: sequence.lisp
+
+;; mkstr
+(mkstr "abc" "def" #\h #\i "klmb")
+;; => "abcdefhiklmb" 
+
+;; position
+(position #\3 "12345")
+;; => 2
+
+;; before, after
+(before #\3 "12345")
+;; => "12"
+(after #\3 "12345")
+;; => "45"
+
+;; string->list
+(string->list #\, "abcd,e,f,,g,hi,j,klmnop,qr,")
+;; => ("abcd" "e" "f" "" "g" "hi" "j" "klmnop" "qr" "") 
+
+
+;; FUNCTION STRING {{{
+;; Syntax:
+;; string x => string
+;;
+;; Arguments and Values:
+;; x---a string, a symbol, or a character.
+;; string---a string.
+;;
+;; Description:
+;; Returns a string described by x; specifically:
+;; If x is a string, it is returned.
+;; If x is a symbol, its name is returned.
+;; If x is a character, then a string containing that one character is returned.
+;; string might perform additional, implementation-defined conversions.
+;;
+;; Examples:
+;;  (string "already a string") =>  "already a string"
+;;  (string 'elm) =>  "ELM"
+;;  (string #\c) =>  "c"
+;; }}}
+;; Function MAKE-STRING {{{
+;; 
+;; Syntax:
+;; make-string size &key initial-element element-type => string
+;;
+;; Arguments and Values:
+;; size---a valid array dimension. 
+;; initial-element---a character. The default is implementation-dependent. 
+;; element-type---a type specifier. The default is character. 
+;; string---a simple string. 
+;; 
+;; Description:
+;; make-string returns a simple string of length size whose elements have been initialized to initial-element. 
+;; The element-type names the type of the elements of the string; a string is constructed of the most specialized type that can accommodate elements of the given type. 
+;; 
+;; Examples:
+;;  (make-string 10 :initial-element #\5) =>  "5555555555"
+;;  (length (make-string 10)) =>  10
+;; 
+;; }}}
+;; FUNCTION STRING=, STRING/=, STRING<, STRING>, ...{{{
+;; string= string1 string2 &key start1 end1 start2 end2 => generalized-boolean
+;; string/= string1 string2 &key start1 end1 start2 end2 => mismatch-index
+;; string< string1 string2 &key start1 end1 start2 end2 => mismatch-index
+;; string> string1 string2 &key start1 end1 start2 end2 => mismatch-index
+;; string<= string1 string2 &key start1 end1 start2 end2 => mismatch-index
+;; string>= string1 string2 &key start1 end1 start2 end2 => mismatch-index
+;; string-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean
+;; string-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index
+;; string-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index
+;; string-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index
+;; string-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index
+;; string-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index
+
+;; string1---a string designator.
+;; string2---a string designator.
+;; start1, end1---bounding index designators of string1. The defaults for start and end are 0 and nil, respectively.
+;; start2, end2---bounding index designators of string2. The defaults for start and end are 0 and nil, respectively.
+;; generalized-boolean---a generalized boolean.
+;; mismatch-index---a bounding index of string1, or nil.
+
+(string= "foo" "foo")
+;; =>  true
+(string= "foo" "Foo")
+;; =>  false
+(string= "foo" "bar")
+;; =>  false
+(string= "together" "frog" :start1 1 :end1 3 :start2 2)
+;; =>  true
+(string-equal "foo" "Foo")
+;; =>  true
+(string= "abcd" "01234abcd9012" :start2 5 :end2 9)
+;; =>  true
+(string< "aaaa" "aaab")
+;; =>  3
+(string>= "aaaaa" "aaaa")
+;; =>  4
+(string-not-greaterp "Abcde" "abcdE")
+;; =>  5
+(string-lessp "012AAAA789" "01aaab6" :start1 3 :end1 7
+              :start2 2 :end2 6)
+;; =>  6
+(string-not-equal "AAAA" "aaaA")
+;; =>  false
+
+;; }}}
+;; Function STRING-UPCASE, STRING-DOWNCASE, STRING-CAPITALIZE, NSTRING-UPCASE, NSTRING-DOWNCASE, NSTRING-CAPITALIZE {{{
+;; 
+;; Syntax:
+;; string-upcase string &key start end => cased-string
+;; string-downcase string &key start end => cased-string
+;; string-capitalize string &key start end => cased-string
+;; nstring-upcase string &key start end => string
+;; nstring-downcase string &key start end => string
+;; nstring-capitalize string &key start end => string
+;; 
+;; Arguments and Values:
+;; string---a string designator. For nstring-upcase, nstring-downcase, and nstring-capitalize, the string designator must be a string. 
+;; start, end---bounding index designators of string. The defaults for start and end are 0 and nil, respectively. 
+;; cased-string---a string. 
+;; 
+;; Description:
+;; string-upcase, string-downcase, string-capitalize, nstring-upcase, nstring-downcase, nstring-capitalize change the case of the subsequence of string bounded by start and end as follows: 
+;; string-upcase 
+;; string-upcase returns a string just like string with all lowercase characters replaced by the corresponding uppercase characters. More precisely, each character of the result string is produced by applying the function char-upcase to the corresponding character of string. 
+;; string-downcase 
+;; string-downcase is like string-upcase except that all uppercase characters are replaced by the corresponding lowercase characters (using char-downcase). 
+;; string-capitalize 
+;; string-capitalize produces a copy of string such that, for every word in the copy, the first character of the ``word,'' if it has case, is uppercase and any other characters with case in the word are lowercase. For the purposes of string-capitalize, a ``word'' is defined to be a consecutive subsequence consisting of alphanumeric characters, delimited at each end either by a non-alphanumeric character or by an end of the string. 
+;; nstring-upcase, nstring-downcase, nstring-capitalize  
+;; nstring-upcase, nstring-downcase, and nstring-capitalize are identical to string-upcase, string-downcase, and string-capitalize respectively except that they modify string. 
+;; For string-upcase, string-downcase, and string-capitalize, string is not modified. However, if no characters in string require conversion, the result may be either string or a copy of it, at the implementation's discretion. 
+;; 
+;; Examples:
+;;  (string-upcase "abcde") =>  "ABCDE"
+;;  (string-upcase "Dr. Livingston, I presume?")
+;; =>  "DR. LIVINGSTON, I PRESUME?"
+;;  (string-upcase "Dr. Livingston, I presume?" :start 6 :end 10)
+;; =>  "Dr. LiVINGston, I presume?"
+;;  (string-downcase "Dr. Livingston, I presume?")
+;; =>  "dr. livingston, i presume?"
+;; 
+;;  (string-capitalize "elm 13c arthur;fig don't") =>  "Elm 13c Arthur;Fig Don'T"
+;;  (string-capitalize " hello ") =>  " Hello "
+;;  (string-capitalize "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION")
+;; =>   "Occluded Casements Forestall Inadvertent Defenestration"
+;;  (string-capitalize 'kludgy-hash-search) =>  "Kludgy-Hash-Search"
+;;  (string-capitalize "DON'T!") =>  "Don'T!"    ;not "Don't!"
+;;  (string-capitalize "pipe 13a, foo16c") =>  "Pipe 13a, Foo16c"
+;; 
+;;  (setq str (copy-seq "0123ABCD890a")) =>  "0123ABCD890a"
+;;  (nstring-downcase str :start 5 :end 7) =>  "0123AbcD890a"
+;;  str =>  "0123AbcD890a"
+;; 
+;; Side Effects:
+;; nstring-upcase, nstring-downcase, and nstring-capitalize modify string as appropriate rather than constructing a new string. 
+;; 
+;; }}}
+;; Function SEARCH {{{
+;; 
+;; Syntax:
+;; search sequence-1 sequence-2 &key from-end test test-not key start1 start2 end1 end2
+;; => position
+;; 
+;; Arguments and Values:
+;; Sequence-1---a sequence. 
+;; Sequence-2---a sequence. 
+;; from-end---a generalized boolean. The default is false. 
+;; test---a designator for a function of two arguments that returns a generalized boolean. 
+;; test-not---a designator for a function of two arguments that returns a generalized boolean. 
+;; key---a designator for a function of one argument, or nil. 
+;; start1, end1---bounding index designators of sequence-1. The defaults for start1 and end1 are 0 and nil, respectively. 
+;; start2, end2---bounding index designators of sequence-2. The defaults for start2 and end2 are 0 and nil, respectively. 
+;; position---a bounding index of sequence-2, or nil. 
+;; 
+;; Description:
+;; Searches sequence-2 for a subsequence that matches sequence-1. 
+;; The implementation may choose to search sequence-2 in any order; there is no guarantee on the number of times the test is made. For example, when start-end is true, the sequence might actually be searched from left to right instead of from right to left (but in either case would return the rightmost matching subsequence). If the search succeeds, search returns the offset into sequence-2 of the first element of the leftmost or rightmost matching subsequence, depending on from-end; otherwise search returns nil. 
+;; If from-end is true, the index of the leftmost element of the rightmost matching subsequence is returned. 
+;; 
+;; Examples:
+;;  (search "dog" "it's a dog's life") =>  7
+;;  (search '(0 1) '(2 4 6 1 3 5) :key #'oddp) =>  2
+;;
+;; Notes:
+;; The :test-not argument is deprecated. 
+;; 
+;; 
+;; }}}
diff --git a/doc/structure.lisp b/doc/structure.lisp
index 4e9dc28..850ae38 100644
--- a/doc/structure.lisp
+++ b/doc/structure.lisp
@@ -1,99 +1,96 @@
-
-
-;; symple declare
-(defstruct point
-  (x 0)
-  (y 0))
-;; => It is made automatically
-;; (make-point ...),
-;; (pointp obj),
-;; (copy-point point),
-;; (point-x point),
-;; (point-y point)
-
-;; like a java's constructor
-(defparameter p (make-point :x 0 :y 0))
-;; => #S(POINT :X 0 :Y 0) 
-
-;; accesser
-(point-x p)
-;; => 0 
-(point-y p)
-;; => 0 
-
-;; is point?
-(point-p p)
-;; <=>
-(typep p 'point)
-;; => T 
-
-;; substitute
-(setf (point-y p) 100)
-(point-y p)
-;; => 100 
-
-
-(defstruct (point (:conc-name p)
-                  (:print-object point-to-string))
-  (x 0)
-  (y 0))
-
-;; print-function
-(defun point-to-string (p stream)
-  (format stream "(~A, ~A)" (px p) (py p)))
-
-(defparameter p (make-point))
-;; => (0, 0)
-
-;; point
-;; @see class.lisp
-(defstruct point ()
-  x y z)
-
-(defmethod norm ((p point))
-  (sqrt
-    (apply #'+ (mapcar (lambda (x)
-                         (* x x))
-                       (list (point-x p)
-                             (point-y p)
-                             (point-z p))))))
-
-
-(defvar *struct* (make-point :x 1 :y 1 :z 1))
-(point-x *struct*)
-;; =>1 
-(point-y *struct*)
-;; =>1 
-(point-z *struct*)
-;; =>1 
-(norm *struct*)
-;; => 1.7320508 
-
-
-
-;; rectangle
-;; @see class.lisp
-
-(defstruct rectangle
-  height width)
-
-(defstruct circle
-  radius)
-
-(defun area (x)
-  (cond ((rectangle-p x)
-         (* (rectangle-height x) (rectangle-width x)))
-        ((circle-p x)
-         (* pi (expt (circle-radius x) 2)))))
-
-(let ((r (make-rectangle))
-      (c (make-circle)))
-  (setf (rectangle-height r) 2
-        (rectangle-width r ) 3
-        (circle-radius c) 5)
-  (area r)
-  (area c))
-;; => 6 
-;; => 78.53981633974483096L0 
-
-
+
+;; symple declare
+(defstruct point
+  (x 0)
+  (y 0))
+;; => It is made automatically
+;; (make-point ...),
+;; (pointp obj),
+;; (copy-point point),
+;; (point-x point),
+;; (point-y point)
+
+;; like a java's constructor
+(defparameter p (make-point :x 0 :y 0))
+;; => #S(POINT :X 0 :Y 0) 
+
+;; accesser
+(point-x p)
+;; => 0 
+(point-y p)
+;; => 0 
+
+;; is point?
+(point-p p)
+;; <=>
+(typep p 'point)
+;; => T 
+
+;; substitute
+(setf (point-y p) 100)
+(point-y p)
+;; => 100 
+
+
+(defstruct (point (:conc-name p)
+                  (:print-object point-to-string))
+  (x 0)
+  (y 0))
+
+;; print-function
+(defun point-to-string (p stream)
+  (format stream "(~A, ~A)" (px p) (py p)))
+
+(defparameter p (make-point))
+;; => (0, 0)
+
+;; point
+;; @see class.lisp
+(defstruct point ()
+  x y z)
+
+(defmethod norm ((p point))
+  (sqrt
+    (apply #'+ (mapcar (lambda (x)
+                         (* x x))
+                       (list (point-x p)
+                             (point-y p)
+                             (point-z p))))))
+
+
+(defvar *struct* (make-point :x 1 :y 1 :z 1))
+(point-x *struct*)
+;; =>1 
+(point-y *struct*)
+;; =>1 
+(point-z *struct*)
+;; =>1 
+(norm *struct*)
+;; => 1.7320508 
+
+
+
+;; rectangle
+;; @see class.lisp
+
+(defstruct rectangle
+  height width)
+
+(defstruct circle
+  radius)
+
+(defun area (x)
+  (cond ((rectangle-p x)
+         (* (rectangle-height x) (rectangle-width x)))
+        ((circle-p x)
+         (* pi (expt (circle-radius x) 2)))))
+
+(let ((r (make-rectangle))
+      (c (make-circle)))
+  (setf (rectangle-height r) 2
+        (rectangle-width r ) 3
+        (circle-radius c) 5)
+  (area r)
+  (area c))
+;; => 6 
+;; => 78.53981633974483096L0 
diff --git a/doc/with-open-file.lisp b/doc/with-open-file.lisp
index 7e3a42b..5b21370 100644
--- a/doc/with-open-file.lisp
+++ b/doc/with-open-file.lisp
@@ -1,94 +1,85 @@
-(load "../lib/stdlib")
-
-;; output
-(with-open-file (out "file-name"
-                     :direction :output
-                     :if-exists :append
-                     :if-does-not-exist nil)
-  (print "hello world" out))
-
-;; input
-(with-open-file (in "file-name"
-                    :direction :input
-                    :if-does-not-exist :error)
-  (let ((line nil))
-    (while (setq line (read-line in nil))
-           (echo line))))
-
-;; keyword parameter
-;; :direction {{{
-
-:input
-;; 入力
-
-:output
-;; 出力
-
-:io
-;; 入出力
-
-; }}}
-;; :element-type {{{
-
-;; }}}
-;; :if-exists {{{
-
-:error
-;; file-errorが返る.
-
-:new-version
-;; デフォルト.より大きなバージョン番号が振られたファイルが作成される.
-
-:rename
-;; 既存のファイルがリネームされて,指定したファイル名のファイルが新規作成される.
-
-:rename-and-delete
-;; 既存のファイルはリネームされてdeleteされるがexpungeされない???そして指定したファイル名のファイルが新規作成される.
-
-:overwrite
-;; 既存のファイルに上書きする.open直後,ファイルポインタはファイルの先頭にある.
-
-:append
-;; 既存のファイルに追加書き込みする.open直後,ファイルポインタはファイルの末尾にある.
-
-:supersede
-;; 既存の新ファイルで置き換える.処理系は可能ならばストリームが閉じられるまで,既存ファイルを新ファイルで置き換えない.
-
-nil
-;; ファイルもストリームも作成しない.nilが返る.
-
-;; }}}
-;; :if-does-not-exist {{{
-
-:error
-;; file-errorが返る.
-
-:create
-;; 空ファイルが作成され,ファイルが既存であった場合のように処理が続行される.ただしif-existsで指定したdirectionは実行されない.
-
-nil
-;; ファイルもストリームも作成されない.nilが返る.
-
-;; }}}
-
-
-
-;; @stdlib.lisp
-
-;; each-line
-(with-open-file (in "with-open-file.lisp" :direction :input)
-  (each-line (echo line)))
-
-;; wirte-to
-(write-to "hello.txt" "path/hoge.txt" :ff :windows)
-
-;; read-from
-(format t "~{~A~%~}" (read-from "with-open-file.lisp"))
-;; <=>
-(let ((vector (read-from "with-open-file.lisp" :vector t)))
-  (dotimes (i (length vector))
-    (format t "~A~%" (svref vector i))))
-;; => print this file.
-
-
-
+(load "../lib/stdlib")
+
+;; output
+(with-open-file (out "file-name"
+                     :direction :output
+                     :if-exists :append
+                     :if-does-not-exist nil)
+  (print "hello world" out))
+
+;; input
+(with-open-file (in "file-name"
+                    :direction :input
+                    :if-does-not-exist :error)
+  (let ((line nil))
+    (while (setq line (read-line in nil))
+           (echo line))))
+
+;; keyword parameter
+;; :direction {{{
+
+:input
+;; 入力
+
+:output
+;; 出力
+
+:io
+;; 入出力
+
+; }}}
+;; :element-type {{{
+
+;; }}}
+;; :if-exists {{{
+
+:error
+;; file-errorが返る.
+
+:new-version
+;; デフォルト.より大きなバージョン番号が振られたファイルが作成される.
+
+:rename
+;; 既存のファイルがリネームされて,指定したファイル名のファイルが新規作成される.
+
+:rename-and-delete
+;; 既存のファイルはリネームされてdeleteされるがexpungeされない???そして指定したファイル名のファイルが新規作成される.
+
+:overwrite
+;; 既存のファイルに上書きする.open直後,ファイルポインタはファイルの先頭にある.
+
+:append
+;; 既存のファイルに追加書き込みする.open直後,ファイルポインタはファイルの末尾にある.
+
+:supersede
+;; 既存の新ファイルで置き換える.処理系は可能ならばストリームが閉じられるまで,既存ファイルを新ファイルで置き換えない.
+
+nil
+;; ファイルもストリームも作成しない.nilが返る.
+
+;; }}}
+;; :if-does-not-exist {{{
+
+:error
+;; file-errorが返る.
+
+:create
+;; 空ファイルが作成され,ファイルが既存であった場合のように処理が続行される.ただしif-existsで指定したdirectionは実行されない.
+
+nil
+;; ファイルもストリームも作成されない.nilが返る.
+
+;; }}}
+
+;; @stdlib.lisp
+
+;; wirte-to
+(write-to "hello.txt" "path/hoge.txt" :ff :windows)
+
+;; read-from
+(format t "~{~A~%~}" (read-from "with-open-file.lisp"))
+;; <=>
+(let ((vector (read-from "with-open-file.lisp" :vector t)))
+  (dotimes (i (length vector))
+    (format t "~A~%" (svref vector i))))
+;; => print this file.
diff --git a/etc/boyer-moore.lisp b/etc/boyer-moore.lisp
index 82926ea..8bb6965 100644
--- a/etc/boyer-moore.lisp
+++ b/etc/boyer-moore.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 ;; Boyer-Moore String Search Algorithm
@@ -34,5 +33,3 @@
 ;; => 0
 (boyer-moore  "icled_pepper" "picled_pepper")
 ;; => 1
-
-
diff --git a/etc/convert-predicate.lisp b/etc/convert-predicate.lisp
index afb3afc..7409af7 100644
--- a/etc/convert-predicate.lisp
+++ b/etc/convert-predicate.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defmacro abbrev (short long)
@@ -128,4 +127,3 @@
 ;; ==
 (eq? 'a 'a)
 ;; => t
-
diff --git a/etc/dice.lisp b/etc/dice.lisp
index 328f7b4..6983b21 100644
--- a/etc/dice.lisp
+++ b/etc/dice.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defparameter *time-limit* 6)
@@ -60,4 +59,3 @@
         (read-line)))))
 
 (dice-with-timer)
-
diff --git a/etc/differential.lisp b/etc/differential.lisp
index d90bda0..f621448 100644
--- a/etc/differential.lisp
+++ b/etc/differential.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defun sum (arg1 &rest args)
@@ -87,4 +86,3 @@
 (d 'x '(* x (* a (+ 4 (* 3 x)))))    ;; (+ 3AX (* A (+ 4 (* 3 X)))) 
 
 ;; }}}
-
diff --git a/etc/dlambda-olambda.lisp b/etc/dlambda-olambda.lisp
index 32566bd..dfe41aa 100644
--- a/etc/dlambda-olambda.lisp
+++ b/etc/dlambda-olambda.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defmacro dlambda (&rest body)
diff --git a/etc/fizz-buzz.lisp b/etc/fizz-buzz.lisp
index 3e3a7da..80155ac 100644
--- a/etc/fizz-buzz.lisp
+++ b/etc/fizz-buzz.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defun fizz? (n)
@@ -28,5 +27,3 @@
       (fizz 'fizz)
       (buzz 'buzz)
       (t i))))
-
-
diff --git a/etc/life.lisp b/etc/life.lisp
index 5ac5c59..08e9a06 100644
--- a/etc/life.lisp
+++ b/etc/life.lisp
@@ -1,4 +1,3 @@
-
 ;; library point
 (defstruct point x y)
 (defmethod x ((p point)) (point-x p))
@@ -86,4 +85,3 @@
     (sleep 1)))
 
 (main)
-
diff --git a/etc/meta.lisp b/etc/meta.lisp
index 16fb69d..ddc048b 100644
--- a/etc/meta.lisp
+++ b/etc/meta.lisp
@@ -71,4 +71,3 @@
   (cond ((null. m) '())
         ('t (cons (eval.  (car m) a)
                   (evlis. (cdr m) a)))))
-
diff --git a/etc/monte-carlo-integration.lisp b/etc/monte-carlo-integration.lisp
index 0f072d8..2ccbcca 100644
--- a/etc/monte-carlo-integration.lisp
+++ b/etc/monte-carlo-integration.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defmacro bind-cordinate (area &body body)
@@ -108,4 +107,3 @@
                            (- 1 (* x x)))
                          (make-point -1 -1) (make-point 1 1))
 ;; ~= 4/3
-
diff --git a/etc/nqueen.lisp b/etc/nqueen.lisp
index 0542f2c..6baf160 100644
--- a/etc/nqueen.lisp
+++ b/etc/nqueen.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defvar *board-size* 8)
@@ -58,5 +57,3 @@
   (fresh-line))
 
 (main)
-
-
diff --git a/etc/numpre.lisp b/etc/numpre.lisp
index c34b9ab..4eecf07 100644
--- a/etc/numpre.lisp
+++ b/etc/numpre.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defvar *box-size* 3)
@@ -91,5 +90,3 @@
           (2  6  9  7  4  1  5 -3 -8)
           (1  7  5  8  3  2  9  6 -4)
           (3  8  4  5  6  9  7 -2 -1))))
-
-
diff --git a/etc/pascal-triangle.lisp b/etc/pascal-triangle.lisp
index ad90eb7..22fdadf 100644
--- a/etc/pascal-triangle.lisp
+++ b/etc/pascal-triangle.lisp
@@ -1,20 +1,18 @@
-
-(require :stdlib *module-stdlib*)
-
-(defun pascal (i j)
-  (when (<= j i )
-    (if (or (= j 0) (= i j))
-      1
-      (+ (pascal (1- i) (1- j))
-         (pascal (1- i) j)))))
-
-(defun pascal-line (i)
-  (mapcar (lambda (j)
-            (pascal i j))
-          (iota 0 i)))
-
-(defun pascal-triangle (i)
-  (mapcar #'pascal-line (iota 0 i)))
-
-(mapcar #'print (pascal-triangle 10))
-
+(require :stdlib *module-stdlib*)
+
+(defun pascal (i j)
+  (when (<= j i )
+    (if (or (= j 0) (= i j))
+      1
+      (+ (pascal (1- i) (1- j))
+         (pascal (1- i) j)))))
+
+(defun pascal-line (i)
+  (mapcar (lambda (j)
+            (pascal i j))
+          (iota 0 i)))
+
+(defun pascal-triangle (i)
+  (mapcar #'pascal-line (iota 0 i)))
+
+(mapcar #'print (pascal-triangle 10))
diff --git a/etc/queueing-theory.lisp b/etc/queueing-theory.lisp
index c404a0d..6bb9c48 100644
--- a/etc/queueing-theory.lisp
+++ b/etc/queueing-theory.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :math *module-math*)
 
@@ -52,4 +51,3 @@
 ;; estimate Wt
 (for (Wt 0.2 (< Wt 0.25) :step 0.001)
   (echo Wt #\tab (ignore-errors (Wr))))
-
diff --git a/etc/ray-tracing.lisp b/etc/ray-tracing.lisp
index 2eb6439..37fa835 100644
--- a/etc/ray-tracing.lisp
+++ b/etc/ray-tracing.lisp
@@ -1,4 +1,3 @@
-
 (defun sq (x)
   (* x x))
 
@@ -119,4 +118,3 @@
   (tracer (make-pathname :name "spheres.pgm") res))
 
 (ray-test)
-
diff --git a/etc/regex.lisp b/etc/regex.lisp
index 91a11c6..d996483 100644
--- a/etc/regex.lisp
+++ b/etc/regex.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :test-utils *module-test-utils*)
 
@@ -224,4 +223,3 @@
    (match? '(#\a #\a aster #\c) "bac")
    '(1 3))
   )
-
diff --git a/etc/reversi.lisp b/etc/reversi.lisp
index 132dc7f..787254f 100644
--- a/etc/reversi.lisp
+++ b/etc/reversi.lisp
@@ -1,4 +1,3 @@
-
 (require :ltk *module-ltk*)
 (require :coordinate-manager *module-coordinate-manager*)
 (require :stdlib *module-stdlib*)
@@ -127,4 +126,3 @@
                 (draw-disc turn r1)
                 (reverse-disc turn r1 it)
                 (setq turn (toggle turn))))))))
-
diff --git a/etc/sort.lisp b/etc/sort.lisp
index 68740a9..0270498 100644
--- a/etc/sort.lisp
+++ b/etc/sort.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 
 (defun merge-sort (lis)
@@ -13,4 +12,3 @@
            lis))
 
 #o(merge-sort (list 1 7 2 3 4 4 3 4 8 6 7))
-
diff --git a/etc/tetris.lisp b/etc/tetris.lisp
index 652cc40..3b56046 100644
--- a/etc/tetris.lisp
+++ b/etc/tetris.lisp
@@ -1,4 +1,3 @@
-
 (require :ltk *module-ltk*)
 (require :coordinate-manager *module-coordinate-manager*)
 (require :stdlib *module-stdlib*)
diff --git a/lib/ahead-reader.lisp b/lib/ahead-reader.lisp
index 5d1be52..8a687fe 100644
--- a/lib/ahead-reader.lisp
+++ b/lib/ahead-reader.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (provide :ahead-reader)
 
@@ -225,4 +224,3 @@
   reader)
 
 ;; }}}
-
diff --git a/lib/coordinate-manager.lisp b/lib/coordinate-manager.lisp
index 0d343aa..58fb7aa 100644
--- a/lib/coordinate-manager.lisp
+++ b/lib/coordinate-manager.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :math *module-math*)
 
@@ -127,4 +126,3 @@
 (defconstant +vector-top-left+ (make-vector -1 1))
 (defconstant +vector-bottom-right+ (make-vector 1 -1))
 (defconstant +vector-bottom-left+ (make-vector -1 -1))
-
diff --git a/lib/csv-reader.lisp b/lib/csv-reader.lisp
index 6be1a70..5c50919 100644
--- a/lib/csv-reader.lisp
+++ b/lib/csv-reader.lisp
@@ -1,4 +1,3 @@
-
 (require :ahead-reader *module-ahead-reader*)
 (provide :csv-reader)
 
diff --git a/lib/database-manager.lisp b/lib/database-manager.lisp
index 57e9421..8926264 100644
--- a/lib/database-manager.lisp
+++ b/lib/database-manager.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :graph-utils *module-graph-utils*)
 (provide :database-manager)
@@ -232,4 +231,3 @@
                      out)))))))
 
 ;; }}}
-
diff --git a/lib/date-utils.lisp b/lib/date-utils.lisp
index b212aa8..5ae7096 100644
--- a/lib/date-utils.lisp
+++ b/lib/date-utils.lisp
@@ -1,4 +1,3 @@
-
 ;; date-util
 ;; day-of-week  {{{
 
@@ -76,4 +75,3 @@
     (= (% y 400) 0)))
 
 ;; }}}
-
diff --git a/lib/graph-utils.lisp b/lib/graph-utils.lisp
index 19cecff..4a8b67c 100644
--- a/lib/graph-utils.lisp
+++ b/lib/graph-utils.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :regex *module-regex*)
 (provide :graph-utils)
@@ -113,4 +112,3 @@
     (call "dot" (list "-Tgif" input-file
                       "-o" output-file)
           *standard-output*)))
-
diff --git a/lib/ltk.lisp b/lib/ltk.lisp
index 6e3cd8e..515e516 100644
--- a/lib/ltk.lisp
+++ b/lib/ltk.lisp
@@ -1,4 +1,3 @@
-
 (provide :ltk)
 
 ;; change log
@@ -5022,4 +5021,3 @@ tk input to terminate"
 		widgets)))
 
 
-
diff --git a/lib/math.lisp b/lib/math.lisp
index 1709b74..792ea7b 100644
--- a/lib/math.lisp
+++ b/lib/math.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (provide :math)
 
@@ -20,4 +19,3 @@
   (let1 (div (expt 10 precision))
     (funcall (if (zerop precision) #'parse-int #'float)
              (/ (funcall fn (* number div)) div))))
-
diff --git a/lib/regex.lisp b/lib/regex.lisp
index c7a19a0..0139f8d 100644
--- a/lib/regex.lisp
+++ b/lib/regex.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :ahead-reader *module-ahead-reader*)
 (provide :regex)
@@ -325,4 +324,3 @@
     (push (make-regex :key key :pat pat :closure closure) regex)))
 
 ;; }}}
-
diff --git a/lib/stdlib.lisp b/lib/stdlib.lisp
index 2641c89..4ae0679 100644
--- a/lib/stdlib.lisp
+++ b/lib/stdlib.lisp
@@ -1,4 +1,3 @@
-
 (provide :stdlib)
 
 (defconstant +null-character+ (code-char 0))
@@ -777,8 +776,7 @@
 ;; princln {{{
 
 (defun princln (str &optional (stream *standard-output*))
-  (princ str stream)
-  (fresh-line stream))
+  (format stream "~A~%" str))
 
 ;; }}}
 ;; println {{{
@@ -1444,4 +1442,3 @@
  |#
 
 ;; }}}
-
diff --git a/lib/test-utils.lisp b/lib/test-utils.lisp
index 37b21cb..5ab46b9 100644
--- a/lib/test-utils.lisp
+++ b/lib/test-utils.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (provide :test-utils)
 
@@ -19,4 +18,3 @@
          (echo (rest ',fn))
          (echo " => " (eval ',fn))
          (echo "    " (eval ',result))))))
-
diff --git a/lib/xml-manager.lisp b/lib/xml-manager.lisp
index 2a3cbe1..fcafcf7 100644
--- a/lib/xml-manager.lisp
+++ b/lib/xml-manager.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :ahead-reader *module-ahead-reader*)
 (require :regex *module-regex*)
@@ -263,7 +262,7 @@
           (#\& "&amp;")
           (#\< "&lt;")
           (#\> "&gt;")
-          (#\© "&copy;")
+          (#\ﾂｩ "&copy;")
           (t c))
         buf))))
 
@@ -289,7 +288,7 @@
                                  ("&" "&amp")
                                  ("<" "&lt")
                                  (">" "&gt")
-                                 ("©" "&copy"))
+                                 ("ﾂｩ" "&copy"))
                                :key #'second))
               (and (read-next reader :cache nil)
                    (first it))
@@ -578,4 +577,3 @@
          (import-xml ,xml)))))
 
 ;; }}}
-
diff --git a/test/coordinate-manager.lisp b/test/coordinate-manager.lisp
index e39ae8b..c55d802 100644
--- a/test/coordinate-manager.lisp
+++ b/test/coordinate-manager.lisp
@@ -1,4 +1,3 @@
-
 (require :coordinate-manager *module-coordinate-manager*)
 (require :test-utils *module-test-utils*)
 
@@ -54,4 +53,3 @@
                   3.0))
 
 ;; }}}
-
diff --git a/test/getopt.lisp b/test/getopt.lisp
index bc5d626..28edc7d 100644
--- a/test/getopt.lisp
+++ b/test/getopt.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :test-utils *module-test-utils*)
 
@@ -156,4 +155,3 @@
   (47
    (getopt '(#.*arg0* "a-z" "A-Z") "a;z")
    '("a-z" "A-Z") '(("a" nil) ("z" nil)) nil))
-
diff --git a/test/graph-utils.lisp b/test/graph-utils.lisp
index 8bedc7c..6f4733d 100644
--- a/test/graph-utils.lisp
+++ b/test/graph-utils.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :graph-utils *module-graph-utils*)
 (require :test-utils *module-test-utils*)
@@ -35,4 +34,3 @@
               :ranks '(("start" "a0" "a1" "a2" "a3")
                        ("b0" "b1" "b2" "b3" "end")))
   :file "graph-utils-cluster-test")
-
diff --git a/test/ltk.lisp b/test/ltk.lisp
index 05fc421..f230c70 100644
--- a/test/ltk.lisp
+++ b/test/ltk.lisp
@@ -1,4 +1,3 @@
-
 (require :ltk *module-ltk*)
 (require :stdlib *module-stdlib*)
 (require :test-utils *module-test-utils*)
@@ -43,4 +42,3 @@
     (pack (list fr1 fr2) :fill :both :side :left)
     (pack btns :fill :both :side :top)))
 
-
diff --git a/test/math.lisp b/test/math.lisp
index b72b0ae..38f2122 100644
--- a/test/math.lisp
+++ b/test/math.lisp
@@ -1,4 +1,3 @@
-
 (require :math *module-math*)
 (require :test-utils *module-test-utils*)
 
@@ -34,4 +33,3 @@
   (pi-03 (pi 1 1 #'identity) 1))
 
 ;; }}}
-
diff --git a/test/regex.lisp b/test/regex.lisp
index 6131ad7..3360883 100644
--- a/test/regex.lisp
+++ b/test/regex.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :ahead-reader *module-ahead-reader*)
 (require :regex *module-regex*)
@@ -158,4 +157,3 @@
   (read-macro-#~m-01 (funcall #~m/${a}/ "abc") "a")
   (read-macro-#~m-02 (funcall #~m/${a.*}b/ "xaaab") "aaab")
   (read-macro-#~m-03 (funcall #~m/${a.*}${$a}a/ "aaa$aa") "aaa$aa"))
-
diff --git a/test/stdlib.lisp b/test/stdlib.lisp
index 296ed5d..56efb0d 100644
--- a/test/stdlib.lisp
+++ b/test/stdlib.lisp
@@ -1,4 +1,3 @@
-
 (require :stdlib *module-stdlib*)
 (require :test-utils *module-test-utils*)
 
@@ -315,4 +314,3 @@ END
   (list->string-05 (list->string nil #\,) ""))
 
 ;; }}}
-
diff --git a/test/xml-manager.lisp b/test/xml-manager.lisp
index 7268c74..f82e832 100644
--- a/test/xml-manager.lisp
+++ b/test/xml-manager.lisp
@@ -1,4 +1,3 @@
-
 (require :xml-manager *module-xml-manager*)
 (require :test-utils *module-test-utils*)
 
@@ -128,4 +127,3 @@ END)
         (to-pre-code (sample-source))
         )))
   "xml-manager.html")
-
